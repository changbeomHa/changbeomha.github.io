[ { "title": "VR 턴제 액션 게임 개발 일지", "url": "/posts/vrgame/", "categories": "게임개발", "tags": "gamedev, 3d modeling", "date": "2023-12-22 18:51:23 +0900", "snippet": "실감미디어 공모전 수상작 VR 턴제 액션 게임의 개발 과정을 간단하게 소개합니다.아래는 데모 영상입니다.프로젝트 목표해결하고자 하는 목표UX 관점에서 바라본 해결해야 할 과제 무거운 장비 인지부조화에 의한 멀미 육체적으로 높은 피로도=&gt; 위 사항을 개선한 사용자 친화적인 VR 게임 조작 방법을 탐구하고, 게임에 적용시켜본다.구현하고자 하는 목표VR의 특성상 고정된 1인칭 시점에서 플레이 하게 됨.이 경우 개발자가 의도하는, 혹은 게임 상황이 강조하는 시네마틱한 연출을 그려내기가 어려움.=&gt; VR에서 2D 스크린의 연출 방식을 구현함으로써 위 문제점을 해결하고자 한다.사용자 경험 디자인 설계 사용자는 현실의 고정된 좌표에서만 플레이한다. 사용자의 안전과 편의를 위해 몸 동작은 정적인 동선을 지향한다. 모든 조작은 핸드 트래킹에 기반한다. 지속적으로 게임을 즐길 수 있도록 하기 위해, 서서 게임을 플레이하거나 팔을 오래 드는 행위의 유도는 지양한다. VR의 특성상 플레이어가 직접 게임에 1인칭으로 개입하는데, 움직임이 제한된 환경에서 이 특성을 살리며 게임을 진행하기 위해 2D 스크린 TPS 게임처럼 플레이어의 시점에서 오브젝트, 캐릭터를 조작하여 게임을 진행한다. 즉, 1인칭 카메라로 플레이 하되, 게임의 오브젝트 배치는 3인칭 시점으로 구축한다.핵심 아이디어콘텐츠 개발 및 디자인" }, { "title": "현장실습 인턴십 업무 관련", "url": "/posts/nurhyme_work/", "categories": "다이어리", "tags": "intern, review", "date": "2023-03-06 16:53:45 +0900", "snippet": "2022년 12월 22일부터 2023년 2월 28일 까지, 3학년을 마치고 동계 방학 기간 동안 판교에 위치한 스타트업에서 실습 근무를 수행했다.근무 기간 중 개발한 기능들을 이곳에 기록한다.shop system client dev list MVC패턴 기반의 상점 시스템 MVC패턴 기반의 인벤토리 시스템 아이템 데이터 관리 및 상호작용 (json, binary, scriptable object) 아이템 타입 변환 작업 UI 레이아웃 관리, UI 애니메이션 async await UI 파티클 시스템 상점 편의 기능 (테스트 재화 충전, 아이템 검색 페이지 등) 랜덤 아이템 뽑기(gacha) 시스템 시네마틱 화면 전환 효과 render texture를 사용한 3D 아이템 오브젝트 렌더링 및 연출 효과 UI 최적화 +) QA기타이 외에도 life cycle이나 awake 스케쥴 관리, 기타 최적화 등 많은 것을 배울 수 있었다. 키워드를 보고 다시 공부하며 되새기자." }, { "title": "캡스톤 디자인 개발 일지 - 개발 8 (논문 기술 연결, 완성)", "url": "/posts/capstone10/", "categories": "캡스톤 디자인", "tags": "game dev", "date": "2022-11-29 15:55:09 +0900", "snippet": "최종적으로 게임이 완성되었다. 다수의 적이 존재하는 훈련 스테이지, 메뉴 기능등과 같은 게임 필수적인 기능을 포함하여 motion puzzle의 스타일 전이, PFNN 등의 기술을 실제 게임에 적용했다.개발 네트워크 연결▪ motion puzzle, PFNN 스테이지 개발▪ 훈련 스테이지 시스템 UI▪ 다시하기, 게임 스테이지 변경 메뉴 [훈련 스테이지 / 스타일 전이 움직임][굴곡이 있는 지형 / PFNN 행동 계산]]결과물 소개 영상최종 프로젝트에 대한 소개 영상은 아래와 같다." }, { "title": "유니티 최적화", "url": "/posts/memo1/", "categories": "개발 메모", "tags": "game dev, memo", "date": "2022-11-23 01:40:35 +0900", "snippet": "메쉬 병합메쉬병합 (Mesh Combine)으로 DrawCall을 줄인다.에셋스토어에 mesh bake가 있으니 다운받아서 사용하자.=&gt; 병합할 mesh들을 쭉 드래그하거나 한곳에 몰아넣어 우클릭 후 mesh Bake를 누르면 Baked Mesh라는 새 오브젝트가 나온다. 기존의 오브젝트는 끄거나 삭제해주자. 베이킹을 할려면 메쉬가 있어야 하는데, 위 방법을 쓰면 메쉬필터가 공백으로 되어 있고 UV가 깨져서 베이킹이 깨지게 된다. 이를 해결할려면 ProBuilder를 다운받고 새로만든 Baked MEsh를 Probuilderize를 해주면 메쉬가 새로 만들어진다. 이후 오브젝트를 static으로 만든 후 오브젝트에 붙어 있는 스크립트 버튼이나 Probuilder 윈도우 창에서 UV generate를 해주면 된다. 이후 베이킹까지 하면 최적화가 아주 크게 된다.코루틴 캐싱코루틴을 사용할 때 가비지가 자주 생성된다. 코루틴을 자주 사용한다면 꼭 최적화를 해주자.일단 StartCoroutine을 호출하는 순간 가비지가 생성된다, 이는 따로 방법이 없으므로 StartCoroutine을 적게 사용해야 할 것이다.두 번째로, YieldInstruction(코루틴에서 yield구문에 사용되는 값)에서 new를 통해 인스턴스를 생성할 때 가비지가 만들어진다. 따라서 이를 캐싱해준다면 가비지가 생성되지 않을 것이다.일단 리턴할 yield 값이 없을 때는 yield return0이 아니라 yield return null을 사용한다. (0을 리턴하면 0의 값은 변수가 박싱처리되기 때문에 가비지가 만들어짐)while문에서 yield를 돌리는 등의 상황과 같이 new가 무수히 생성될 때,WaitForSeconds waitfor = new WaitforSeconds(1f);를 만들고 while에는 yield return waitfor을 넘겨주는 식으로 캐싱을 해준다.더 자세한 내용은 여기를 참고하자.https://ejonghyuck.github.io/blog/2016-12-12/unity-coroutine-optimization/추가) 코루틴 팁함수가 끝나고 실행되고 싶을 때, ex) first()가 끝나고 second()가 실행되길 원하는 경우.IEnumerator delay(){ yield return StartCoroutine(first()); yield return StartCoroutine(second());}으로 하면 first가 실행되고 끝난 후 second가 실행됨.시간초로 구별하고프면 그냥 WaitForSeconds(n)을 쓰면 됨.배치와 드로우콜라이트 맵 구글링 (정적 오브젝트들은 미리 라이트를 구워, 실시간 라이팅 계산을 줄인다. 이거만 잘 써도 굉장한 도움이 된다)(레이어별로 빛을 받을 물체와 빛 계산을 하지 않을 물체를 나눈다)+) 좀 더 조사할 것resolutionUHD로 맞추면 60프레임을 못낸다. (2020년 표준)게임은 HD해상도로 맞춘다 (1280 * 720)모바일에선 큰 차이 없지만, 패드 등의 대화면으로 넘어가면 HD만으로는 조금 흐리게 나오므로 옵션으로 FHD까지 허용가능토록 한다.참고 ) FHD =&gt; 1920 * 1080FrameRatepc에서는 딱히 생각하지 않지만, 모바일에서는 매우 중요하다. (배터리 + 발열)60프레임으로 가면 발열이 꾸준히 증가한다. =&gt; 일정 온도에 도달하면 기기에서 cpu를 다운시킨다.(rpg의 경우) 프레임을 30까지 낮추자. (45까지도 괜찮다. 발열이 천천히증가하며, 리미트까지 올라가지는 않는다.)프레임 조절 2가지 방법 setresolution =&gt; 스크립트 프레임조절 playerSetting =&gt; fixdDPI =&gt; 화면스크린에 따라 조절전체 해상도 720P 기준 비율 적용, Frame rate 동적 적용 (인트로에서는 30, 배틀에서는 60 과 같은)=&gt; 발열량이 정말 크게 감소한다.활성화/비활성화 관련ui가 나왔을 때 캐릭터가 안보인다면, 그냥 캐릭터를 비활성화 시키자. 그런 식으로 용량을 줄인다. (UI레이어 최적화, UI로직 최적화)수 많은 오브젝트를 사용할 때, Object Pooling으로 구현한다. 유니티에서 Destroy + Instantiate를 사용하는 것 보다, SetActive로 구현하는 것이 훨씬 메모리 효율이 좋다.Scene 이동도 역시 동일한데, 특정한 Scene이 아니면 한 scene에 레벨을 몰아 넣어 SetActive와 position이동으로 구현하는게 좋다고 한다. (모바일 기준, 오픈월드 제외)디자인 패턴싱글톤 패턴, MVC 패턴 등 적극 활용하자UI 관련 이미지 파일들을 사용할 때, 그 크기 (Default의 Max Size)를 이미지의 최소크기 (n x n)형태에서 n보다 크면서 선택범위중 가장 작게 해주자. 캔버스는 분할한다. 유니티는 UI에 변화가 생길 때 캔버스 전체를 다시 그리기 때문에, 비효율적인 성능 낭비가 발생한다. 따라서 큰 틀 단위로 캔버스를 분할하도록 하자. 스프라이트 렌더러와 이미지의 동작 방식을 이해하고 사용처를 명확히 알아두자. sprite renderer의 경우는 자기 자신에 대한 메쉬를 독단적으로 렌더링 한다. 따라서 주로 애니메이션 등(ex. 2d 캐릭터의 움직)에서 사용된다. 반면 image의 경우는 canvas와 함께 렌더링된다. 주로 UI 위에서 상세한 position value를 요구할 때 사용된다.함수 사용 관련GetComponent, Find 등 많은 계산을 요구하는 함수는 가급적 사용을 지양한다." }, { "title": "캡스톤 디자인 개발 일지 - 개발 7 (보스 입장 + 보스 스테이지, 기타)", "url": "/posts/capstone9/", "categories": "캡스톤 디자인", "tags": "game dev", "date": "2022-11-20 15:55:09 +0900", "snippet": "이번 주에는 보스와 관련된 버그를 대폭 수정했다. 일부 밸런스 패치를 적용했으며, 플레이어와 보스 사이에서 발생하던 여러 에러사항을 고치는데 많은 시간을 허비했다..메인 개발 내용으로는, 수 많은 관중이 환호하는 보스 스테이지로 입장하는 씬을 개발했다.훈련 스테이지를 클리어하면 이 씬으로 연결되어 보스 스테이지에 입장할 것이다. 훈련 스테이지는 다음 주에 개발한다.개발 컷씬 개발▪ 보스 입장 스테이지 개발▪ 보스 스테이지 시스템 UI▪ 게임 클리어, 씬 전환 [시스템 UI : 게임 클리어]보스 입장" }, { "title": "캡스톤 디자인 개발 일지 - 개발 6 (적 AI part.3, 인트로 + 튜토리얼 스테이지)", "url": "/posts/capstone8/", "categories": "캡스톤 디자인", "tags": "game dev", "date": "2022-11-15 19:40:46 +0900", "snippet": "이제부터 게임의 무대, 스테이지를 개발할 것이다.또한 게임의 컨셉에 맞추어 스테이지가 진행되기에, 그동안 불확실했던 게임 진행 방향성과 테마를 구체화 했다.선정 논문이 motion style transfer이기 때문에, 많은 애니메이션을 배울 수 있다는 점에서 프로토타입 봇의 이야기를 그려보기로 했다.개발 Ai 개선▪ 피격시 스턴판정(피격 모션 실행) -&gt; 스턴이 3초 이상 지속되면 스턴여부에 상관없이 반격(공격모션 실행) 사운드 효과 추가 컷씬 개발▪ 인트로 스테이지 개발▪ 튜토리얼 스테이지 게임 컨셉 구체화▪ 어디에나 있는 ‘프로토타입 봇’, 신작 게임의 메인 캐릭터 선발 시험에 지원하다.▪ 플레이어는 마지막 테스트(보스)를 앞두고, 그동안 연습했던 기억(튜토리얼)을 떠올려본다… 인트로 + 튜토리얼시험 대기장에 앉아있던 플레이어가 호출되며 게임이 시작된다. 다이얼로그는 csv파일을 파싱하여 불러올 수 있도록 만들었다.마지막 시험(보스 스테이지)을 남겨둔 플레이어는 입장에 앞서 지난 훈련(튜토리얼 스테이지 + 훈련 스테이지) 기억을 떠올려 본다. 안개가 걷히며 플레이어의 기억 속으로 들어가고, 튜토리얼 스테이지가 시작된다." }, { "title": "캡스톤 디자인 개발 일지 - 개발 5 (보스 part.2, 기타)", "url": "/posts/capstone7/", "categories": "캡스톤 디자인", "tags": "game dev", "date": "2022-11-08 10:45:13 +0900", "snippet": "보스가 완성되었다. 기획 단계였던 저번 주에서, 실질적인 기능과 플레이어 상호작용을 모두 구현했다.아직 밸런스 확인도 덜 되었고 보스의 위압감도 생각보다 약한 것 같지만, 생각했던 기능은 모두 잘 작동되어 다행이다.개발특정한 패턴을 가진 보스 구현 Part 2 레이저 빔약 1.5초간 힘을 모으고 플레이어 위치로 레이저 빔을 발사한다.이 동안 천천히 플레이어 방향으로 회전한다.플레이어는 빔과 플레이어가 충돌하는 동안 1초 간격으로 데미지를 받는다. 점프, 낙하하늘로 높이 점프한다. 약 3초 후 낙하 범위가 생성되며, 1초 후 플레이어 위치로 낙하한다.낙하 범위에 플레이어가 존재하면 큰 데미지와 함께 앞으로 넘어지며 2초 기절한다. 블록 설치땅으로 주먹을 내려찍는다. 이 때 4 방향에 특정한 블록이 생성된다.블록이 생성되는 방향으로 라인이 나타나며, 플레이어는 바위 블록 근처에서 G키를 눌러 바위를 파괴할 수 있다.제한시간 내에 파괴하지 못하면 블록에서 적이 생성된다. 바위 던지기땅에서 바위를 뽑아 플레이어 위치로 던진다. 바위는 보스의 위치와 플레이어 위치 사이를 포물선을 그리며 날아간다.플레이어와 바위가 충돌하면 데미지를 받고 뒤로 넘어지며 2초간 기절한다. 이후 바위가 즉시 파괴된다.플레이어가 바위를 피하면 2초 후 파괴된다.추가 구현 심박수 메커니즘 사용 강제치명타 공격을 사용하지 않고 게임 클리어가 가능함을 방지하기 위해 새로운 룰을 도입했다. 모든 적은 보호막을 갖는다. 체력이 일정 이하로 떨어지면 보호막이 활성화 되며 이 동안 데미지를 받지 않는다. 보호막은 치명타 공격으로만 파괴할 수 있다. 기타 시스템 UI 개발 중[보호막 활성 / 파괴][시스템 UI : 게임 시작]" }, { "title": "캡스톤 디자인 개발 일지 - 개발 4 (보스 part.1)", "url": "/posts/capstone6/", "categories": "캡스톤 디자인", "tags": "game dev", "date": "2022-10-25 19:25:33 +0900", "snippet": "이번에는 게임의 메인 스테이지, 보스를 개발한다. 보스의 역할은 게임에 확실한 엔딩성을 주는 것이기에, 다른 적 보다 강력하고 독특해야 한다.보스 개발은 분량이 많은 만큼 2주에 걸쳐 진행한다. 이번 주에는 기획 내용을 구현한다는 느낌으로 모션 및 이펙트 등을 확인 할 것이고, 다음 주에 실질적인 디자인 작업, 상호작용과 오브젝트 계산을 더해 마무리 될 것이다.개발특정한 패턴을 가진 보스 구현 Part 1 레이저 빔약 1.5초간 힘을 모으고 플레이어 위치로 레이저 빔을 발사한다.이 동안 천천히 플레이어 방향으로 회전한다. 점프, 낙하하늘로 높이 점프한다. 약 3초 후 낙하 범위가 생성되며, 1초 후 플레이어 위치로 낙하한다. 블록 설치땅으로 주먹을 내려찍는다. 이 때 4 방향에 특정한 블록이 생성된다. 바위 던지기땅에서 바위를 뽑아 플레이어 위치로 던진다." }, { "title": "캡스톤 디자인 개발 일지 - 개발 3 (적 테스트 + 부위 별 피격)", "url": "/posts/capstone5/", "categories": "캡스톤 디자인", "tags": "game dev", "date": "2022-10-18 15:25:33 +0900", "snippet": "이번 주에는 게임의 밸런싱을 위한 일부 테스트 과정을 거쳤으며, 필수 조건이었던 부위 별 피격을 구현했다.개발밸런싱 및 효과 테스트 치명타 공격의 타격 효과를 위해 일반 공격의 타격감 저하 공격 쿨타임 조정 및 애니메이션 속도 향상, 게임의 전반적인 속도감 UP 크기가 다른 적 테스트 (플레이어를 기준으로)[액션 게임에 맞추어 속도감 조정 중][크기가 다른 적 예시) 골렘]적 공격 추가 (20% 확률로 로우킥)부위별 피격 기능 구현 왼쪽 피격 : 우측으로 휘청 오른쪽 피격 : 좌측으로 휘청 머리 피격 : 뒤로 휘청 치명타 피격 : 뒤로 조금 밀려남 하반신 피격 : 넘어짐 (플레이어)[부위별 피격 + 치명타 피격][일반 피격 + 넘어짐]" }, { "title": "컴퓨터 네트워크 - 2) MAC", "url": "/posts/network2/", "categories": "네트워크", "tags": "network", "date": "2022-10-12 23:32:59 +0900", "snippet": "컴퓨터 네트워크의 구조와 원리에 대해서 공부합니다.이 포스트는 경희대학교 컴퓨터 네트워크 수업자료를 바탕으로 합니다." }, { "title": "컴퓨터 네트워크 - 1) 기본 개념 & OSI 7 Layer", "url": "/posts/network1/", "categories": "네트워크", "tags": "network", "date": "2022-10-12 19:00:02 +0900", "snippet": "컴퓨터 네트워크의 구조와 원리에 대해서 공부합니다.이 포스트는 경희대학교 컴퓨터 네트워크 수업자료를 바탕으로 합니다.1. OSI 7 LayerOSI 7 Layer(Open Systems Interconnection Reference Model) 국제표준화기구(ISO)에서 개발한 모델로, 컴퓨터 네트워크 프로토콜 디자인과 통신을 계층으로 나누어 설명한 것. 기본 내부 구조 및 기술에 관계없이 통신, 컴퓨팅 시스템의 통신 기능을 특성화하고 표준화하는 개념적 모델.위의 그림은 통신에 대한 예시를 나타낸다. 송신자 Maria와 수신자 Ann이 메시지를 주고받는 과정을 OSI Layer으로 살펴보자. 각 레이어들의 위와 아래는 서로 상관없이 독립적이다.Maria의 Layer3에서 Plaintext가 Encrypt되면서 Layer2로 보내진다. 이후 Layer1로 이동하면서 Sender는 Receiver의 Layer1로 비트 정보를 보낸다. 이를 Layer2로 올려 Decrypt하고, Layer3으로 보내 메시지를 수신하게 된다. 즉 송신과정에서의 Layer 이동과 수신과정에서의 Layer이동은 서로 역순임을 알 수 있다. 위의 예시를 이해하고, OSI 7 layer를 알아보자.▶ Application Layer기능 : message format, human-machine interface, (예시 : UI, 메뉴 구성 등)대표 프로토콜 : HTTP, DNS, SNMP, FTP ▶ Presentation Layer기능 : 암호화, 압축대표 프로토콜 : SSL, TLS▶ Session Layer기능 : Authentication(인증 ex.로그인)검증, permissions(권한), 세션 복원대표 프로토콜 : API’s, Socket, NetBIOS, PPTP▶ Transport Layer기능 : end-to-end 에러 검출(네트워크에서의 에러 검출)대표 프로토콜 : TCP, UDP▶ Network Layer기능 : (컴퓨터를 연결하는 줄이 하나보다 더 많아졌을 때) 라우팅 및 트래픽 제어를 포함한 multi-node network 구조화 + 관리 및 패킷 전달, 데이터 전송 시 주소가 생긴다.대표 프로토콜 : IP, IPX▶ Data Link Layer기능 : 에러검출, flow control on physical link(데이터 송수신량 조절, 흐름제어)대표 프로토콜 : Ethernet, ATM▶ Physical Layer기능 : 비트(0과 1) 전달, 물리적 송/수신 대표 프로토콜 : Ethernet, 블루투스1 ~ 4 Layer는 kernel에 위치하며, 그 중 3 ~ 4 는 OS에 위치한다.5 ~ 7 Layer는 Application 레벨으로 구분한다.앞으로의 포스트에서 위 레이어 하나하나에 대해 자세하게 살펴볼 것이다.계층화 예시에 대해 좀 더 살펴보자. 두 개의 통신 장치에 의한 데이터 처리에 대한 수행 과정은 다음과 같다.» 전송될 데이터는 전송 장치의 최상위 layer(layer N)에서 PDU(protocal data unit)로 구성된다.» PDU는 계층 N-1로 전달되며, 이는 SDU(Service Data Unit)라고 한다.» layer N-1에서 SDU는 header, footer 또는 둘 다로 연결되어 layer N-1의 PDU를 생성한다. 이후 layer N-2로 전달된다.» 이 과정은 데이터가 수신 장치로 전송되는 최하위 레벨에 도달 할 때까지 계속된다.» 수신 장치에서, 데이터는 가장 낮은 layer에서 가장 높은 layer으로 SDU가 최상위 레이어에 도달 할 때 까지 전달된다." }, { "title": "캡스톤 디자인 개발 일지 - 개발 2 (고유 매커니즘, 적 AI part.2)", "url": "/posts/capstone4/", "categories": "캡스톤 디자인", "tags": "game dev", "date": "2022-10-11 21:42:33 +0900", "snippet": "이번에는 개발하는 게임의 고유한 시스템을 구현했다. 리듬 게임의 타이밍을 맞추는 매커니즘을 가져와 게임에 맞게 적용했고, 기타 연출효과나 적 AI 등을 일부 개선했다.심박수 시스템의 경우는 수 많은 노드를 재사용 해야 하기 때문에, Object Pooling으로 구현했다.개발심박수 시스템 추가 우측 하단에 노드 ui 및 치명타 활성 ui 배치 타이밍에 맞게 3번 이상 누르면 감소, 틀리거나 놓치면 범위(1~3) 증가 침착함 : 70 유지 시 각성모드 -&gt; 치명타 공격 가능 과부화 : 80을 넘어가면 2초간 기절연출효과 치명타 씬 파이널 어택 씬난이도 조정 적이 범위 내에 있는 경우 플레이어의 공격방향이 항상 적을 향함적, 플레이어 HP 시스템 추가 피격 시 체력 감소, 0이 되면 데스적 AI 개선 플레이어와 거리를 계산하며 xz상하좌우로 움직임 공격 변수가 할당되면 플레이어를 추격해 공격" }, { "title": "캡스톤 디자인 개발 일지 - 개발 1 (공격 및 피격 등의 상호작용, 적 AI part.1)", "url": "/posts/capstone3/", "categories": "캡스톤 디자인", "tags": "game dev", "date": "2022-10-04 20:12:49 +0900", "snippet": "캡스톤 디자인의 개발 결과물으로 액션게임이 만들어져야 한다. 이번 주는 액션게임의 핵심 컨텐츠인 적과 상호작용하는 공격시스템을 개발했다.(이전 개발 과정이었던 플레이어 움직임이나 기타 기본적인 개발 과정은 생략했다)개발공격 상호작용 구현 플레이어의 공격 구분 4가지 범위 (오른손, 왼손, 오른발, 왼발) 적 공격 1가지 (오른손)간단히 움직이고 플레이어를 공격하는 적 AI 구현 플레이어 추적 공격 가능한 범위에 플레이어가 있다면 플레이어를 공격테스트 공격 애니메이션 수정 (애니메이션은 mixamo에서 가져왔다) Boxing, Cross Punch, Inside Crescent Kick, MMA Kick디테일 업그레이드 1 캐릭터 애니메이션 세팅값 수정 모션 실행 후 캐릭터 회전값이 고정됨" }, { "title": "캡스톤 디자인 개발 일지- 논문 세미나", "url": "/posts/capstone2/", "categories": "캡스톤 디자인", "tags": "deep learning", "date": "2022-09-13 22:30:51 +0900", "snippet": "개발에 앞서, 타겟 논문 Motion Puzzle: Arbitrary Motion Style Transfer by Body Part에 대한 세미나를 진행하였다. 이번 포스트에는 논문에 대한 간략한 설명을 포스팅할 것이다.딥러닝에 대한 기본 이해가 필요하다. 네트워크 동작 방식 및 그래프 구조, 가중치 등 기본 개념을 알고 있으면 논문을 읽는데 많은 도움이 된다. 같은 팀원 중 한 분이 제작한 세미나 자료를 기반으로 포스트를 한다.논문 Contribution• 개별 신체 부위의 모션 스타일을 제어할 수 있는 최초의 모션 스타일 전송 방법이다.• 새로운 2단계 스타일 적응 네트워크인 BP StyleNet 및 BP ATN은 모션 스타일의 global 및 local 기능을 spatially하게, 그리고 temporally하게 transfer한다.• style labeling이나 training data의 모션 pairing 없이 Arbitrary(zero-shot) style transfer 가능하다.ArchitectureMotion위 사진에 대한 보충 설명이다.타겟 모션은 스타일 추출을 위한 모션이며, 이는 신체 또는 신체 부위가 그 대상이 될 수 있다.소스 모션은 content를 위한 모션이며, 출력 동작을 위한 모션으로 설명된다.Spatial-temporal graph위 그림에서 노란 선으로 이어진 부분은 Temporal graph이며, 아는 single vertex들의 consecutive한 상태를 나타낸다.또한 위 그림에서 붉은 선으로 이어진 부분이 Spatial graph이며, single frame의 전체 모션을 나타낸다.즉 시간적, 공간적인 특성의 그래프라고 이해할 수 있다.Skeleton based graph convolutional network사진의 정점 v에 대하여, 컨볼루션 네트워크의 수식은 아래와 같다.Graph pooling and unpooling위 사진은 그래프 폴링에 대한 것이다.여러 해상도의 경우를 위해 temporal dimension에 대한 표준 평균 풀링, spaatial dimensioni에 대한 특정 평균 풀링을 고려한다.Style Encoder위 그림은 multi level encoding block 연결과정으로써, 중간 스타일 특징을 점진적으로 추출한다.Content encodeerContent encoder를 보면, Style encoder와 유사함을 알 수 있다.하지만 style normalization에는 IN을 사용하며, Content encoder는 최종 output에만 사용된다.DecoderDecoder는 content feature을 output motion으로 변환한다.• style feature의 global 및 local characteristics를 transfer한다.fs^Gi에서 fd^Gi로 거치는 과정을 2단계 transfer 모듈을 통해 가는데, 이 모듈에서 각각 BP-AdaIN, BP-ATN이 사용된다.BP-AdaIN논문에서 사용된 BP-AdaIN 공식을 살펴보자.• f hat d ^ Gi를 생성하기 위해 style feature의 global statistics를 transfer한다.• fd^Gi를 입력으로 취하고 신체 부위별로 AdaIN을 적용하여 style feature fs^Gi를 inject 한다.BP-ATNBP-AdaIn에 이어 BP-ATN은 어떻게 적용되었는지 알아보자.• locally semantic style feature를 transfer한다.• 동일한 신체 부위의 part-feature 간의 대응 관계를 매핑한다.• 위에서 수식의 좌변은 style feature의 α번째 vertex과 decoded feature의 β번째 vertex 사이의 similarity를 측정한다.• 두 vertex 사이의 similarity가 높을수록 두 vertex 사이의 spatial-temporal 상관관계가 더 커지게 된다." }, { "title": "캡스톤 디자인 개발 일지 - 준비", "url": "/posts/capstone1/", "categories": "캡스톤 디자인", "tags": "deep learning", "date": "2022-09-06 23:32:59 +0900", "snippet": "캡스톤 디자인 개발 주제가 확정되었다. 논문을 하나 선택하고, 논문에 있는 기술을 구현할 것 부위 별 피격에 대한 출력이 다른 액션 게임을 개발할 것위 두가지 조건을 만족하는 결과물을 만들어내야 한다. 이 포스트에 개발과정을 기록할 것이다.우리 팀의 타겟 논문은 2022년 SIGGRAPH에 투고된 Motion Puzzle: Arbitrary Motion Style Transfer by Body Part으로 결정했다. 모션 스타일 트랜스퍼의 개념에 대해 간단히 소개하자면, 서로 다른 모션을 섞어 다른 스타일의 모션을 출력하는 것이다. 아래 사진과 함께 예시를 보자.예를 들어 같은 펀치 동작 이라도 행동이 미숙한 아기와 복싱 선수를 비교하면 체격, 습관 등에 따라 서로 다른 모션을 보일 것이다. 이러한 특징을 motion의 style로 정의하고, 그런 동작(style의 여집합)을 motion의 content로 정의한다. 이렇게 정의한 어떤 style motion의 style을 다른 style을 가진 content motion에 전이시켜 Content Motion의 Content와 Style Motion의 Style을 가지고 있는 새로운 모션으로 바꿔주는 것이다.여기서 나아가 이 논문은 몸 전체의 style을 전이하는 것이 아닌 팔, 허리, 다리 세 가지 파트로 나누어 각 파트에 별개의 style을 입힐 수 있도록 네트워크를 설계했다.이를 구현한다면, 점프하는 모션과 펀치하는 모션을 섞으면 점프하며 펀치하는 모션을 출력할 것이고, 노인의 행동 스타일과 펀치 모션을 섞으면 힘겹게 펀치를 지르는 모션을 출력할 것이다.이제 이 논문에 대한 상세한 분석 후, 논문을 적용할 게임을 만들기 시작할 것이다." }, { "title": "유니티 간단한 셰이더 테스트 + 물리법칙", "url": "/posts/memo3/", "categories": "개발 메모", "tags": "game dev, memo", "date": "2022-08-23 01:29:20 +0900", "snippet": "2년 전 임시 블로그에 있던 글을 옮겨왔다.부력 물리 계산(영상의 2 번째 scene)삼각함수 법칙에 의하여, x축은 cos로, y축은 sin으로 구하자.파도에 사용된 sin함수 =&gt; 진폭(float형 변수) * Mathf.Sin(길이 / offset);부력 효과를 만들 때, 면의 모양에 따라 (물에 닿는 꼭짓점의 개수만큼) 중력을 나누어 주고, 각 꼭짓점 마다 부력 효과 스크립트를 모두 붙인다. 힘을 주는 효과는 AddForceAtPosition으로 만든다.테스트로 직육면체는 4개, 구는 한개를 주었다. 나누는 값을 (floatCount)라 한다면,=&gt; rb.AddForceAtPosition(Physics.gravity / floaterCount, transform.position, ForceMode.Acceleration);ForceMode.Acceleration 질량을 무시하고, rigidbody에 연속적인 가속력을 가한다.ForceMode.VelocityChange 질량을 무시하고, rigidbody에 같은 순간적인 속도변화를 적용한다.AddTorquerigidbody에 토크를 추가하여, rigidbody가 토크 축을 중심으로 회전하기 시작한다.포물선 계산(영상 소리주의!)포물선에 대한 계산은 Vector로 이루어진다.먼저 생성지점(origin)과 목표지점(target), 그리고 생성지점부터 목표지점까지 도달하는데 걸리는 시간(time)을 계산한다.이후, Vector3로 목표지점에서 생성지점을 뺀 변수를 만든다. Vector3 distance = target - origin그리고 이 값을 다른 벡터값에 저장해둔다. Vector3 distanceXz = distancedistanceXz의 y값은 0으로 만들어준다. distanceXz.y = 0f;distance의 y값, distanceXz의 길이를 담는 float형 변수 2개를 만든다. float sY = distance.y; float sXz = distanceXz.magnitude;그리고 sXz에 시간을 곱해준 값과, sY를 시간으로 나눈 값과 중력의 y절대값과 시간의 곱을 더한 float형 변수 2개를 만든다 float Vxz = sXz * time; float Vy = (sY / time) + (0.5f * Mathf.Abs(Physics.gravity.y) * time)결과값은 Vector3 result = distanceXz.normalized로 만들어주고, result *= Vxz, result.y = Vy로 해준다.그리고 이 벡터함수가 result를 반환하도록 만들어준다.이 벡터함수를 담은 변수를 업데이트문에서 실행해주고, 그 변수를 물체의 Rigidbody의 velocity에 넘겨주자.+) 유니티에서는 Slerp라는 구면 선형 보간에 기반한 이동 함수가 존재한다. 이를 사용하면 위와같은 공식을 사용하지 않고도 쉽게 포물선 이동을 구현할 수 있다. smoothdamp, lerp, slerp등은 알아두면 굉장히 유용하게 사용할 수 있다." }, { "title": "유니티 팁", "url": "/posts/memo2/", "categories": "개발 메모", "tags": "game dev, memo", "date": "2022-08-20 01:20:35 +0900", "snippet": "2년 전 임시 블로그에 있던 글을 옮겨왔다. 유니티와 관련한 팁은 이 포스트에 쭉 추가하자. 셰이더 코드를 스크립트로 가져와 사용할 때는, (float형 변수를 받을 때를 예시로)Material[] mats = meshRenderer.materials; 로 받은 후, mats[n].SetFloat(“사용할 변수명”, 수학)으로 가져올 수 있다.셰이더와 머티리얼에 대한 공부가 필요하다. 유니티 파일 첫 실행시 나오는 유니티 로고화면에 Player Setting의 Splash Image - Logos에서 커스텀 이미지를 추가할 수 있다. 일정한 간격으로 오브젝트 정렬 =&gt; edit - snap settings - snap all axes 오브젝트에 텍스쳐 그리기 =&gt; poly brush 컷씬 연출은 DOTween과 Timeline이면 웬만한건 다 될 것이다. 적절히 잘 사용하자. 커스텀 에디터를 만들면 해당 장르 게임을 개발할 때 편리하니, 만들어보자 Timeline Animation Track은 순서에 영향을 받는다. 모션animation(걷기, 점프 등)은 타임라인에서 직접 커스텀한 animation(위치이동이나 회전 등)보다 위에 있어야 한다. 씬뷰에서 메인카메라 선택이 되어있는 상태에서 컨트롤 + 시프트 + F 누르면 씬뷰에서 보는대로 게임뷰에 카메라 세팅이 된다. " }, { "title": "그래픽스 실전4", "url": "/posts/graphics7/", "categories": "그래픽스", "tags": "graphics", "date": "2022-08-14 14:37:06 +0900", "snippet": "계속해서 pixel shader에 대해 알아보겠습니다. 이번에는 Lighting에 대한 내용을 다루어보겠습니다. 아마 유니티나 언리얼에 대한 경험이 있다면, 도움이 많이 될 것입니다.이 포스트는 경희대학교 게임 그래픽 프로그래밍 수업자료를 바탕으로 합니다.6-6. LightingLighting▪ 조명이란 빛과 사물의 상호작용을 다루는 기법을 말한다.▪ 가장 대중적인 조명 방식은 Phong model을 기반으로 한다. 상업용 게임에 널리 사용되며 다양한, 고급의 조명 기술 기반을 마련하도록 한다.Phong model▪ Phong model은 4개의 항으로 구성된다.• Diffuse• Specular• Ambient• Emissive광원의 유형▪ Point light• 한 지점에서 모든 방향으로 빛을 방출한다.• 빛의 강도는 거리에 따라 감소한다.▪ Directional light (the light which is extremely far away from the scene) • 한 방향에서 균일하게 장면을 비춘다.• 빛의 강도가 거리에 따라 변하지 않는다.▪ Spotlight• 원뿔 모양의 조명을 만든다.• light cone과 spotlight sourrce의 중심에 가까울수록 강도가 증가한다.▪ Ambient• 광원이 없어도 물체를 비춥니다. (일정한 빛)• 빛의 강도가 완전히 균일하다.6-6-1. Diffuse TermDiffuse light(확산광)이란?▪ Diffuse light는 직사광선이 표면에 닿을 때 산란광을 나타낸다.▪ 빛이 균일하게 분산됩니다.PhongLighting 모델의 Diffuse term▪ Diffuse term은 이상적으로 확산된 표면의 반사가 모든 방향에서 동일한 강도로 산란된다는 Lambert의 법칙을 기반으로 한다.▪ 따라서 인지되는 반사량은 view driection과 무관하며 들어오는 빛의 양에 비례한다.=&gt; 카메라의 위치와 관계없이, 빛의 세기에 영향을 받음확산 계산▪ light 벡터(l)와 surface norrmal(n)을 고려해보자.▪ diffuse term은 max(n·l, 0)sd⊗md에 의해 결정될 수 있다. 여기서 sd는 광원의 RGB 색상, md는 물체 재료의 확산 반사율, ⊗는 성분별 곱셈을 의미한다.• term max(n· l, 0)는 밝기를 결정하기 위해 빛의 각도를 고려한다. • material parameter인 md는 재료 속성을 고려하여 조명의 색상을 변경한다. 백색광(1, 1, 1)을 가정하자. 빛에 의해 조명된 물체가 노란색으로 보인다면 물체가 R과 G를 반사하고 B를 흡수한다는 것을 의미한다. material parameter를 통해 이러한 종류의 필터링을 쉽게 구현할 수 있다. 즉, (1,1,0)이면 ( 1,1,1)⊗(1,1,0)=(1,1,0)인 것이다. 아래 그림을 보자.6-6-2. Specular Term금속 표면을 생각하자.specular term은 하이라이트를 통해 표면을 빛나게 만드는 데 사용되며, light 벡터(l) 외에 view 벡터(v)와 reflection 벡터(r)가 필요하다.reflection vector 계산은 아래와 같다.(n과 l은 normalized vector이다)반사되는 빛과 view direction이 같을 때 가장 강도가 강할 것이다.Diffuse term은 view-independent지만, Specular term은 view-dependent하다.▪ 완벽하게 빛나는 표면을 위해 p의 하이라이트는 ρ가 0일 때만 보인다.▪ 광택이 전혀 나지 않는 표면의 경우 ρ가 0일 때 최대 하이라이트가 발생하지만 ρ가 증가함에 따라 이 수치는 급격히 떨어진다.6-6-3. Ambient Termambient light(주변광)이란?▪ ambient light은 간접조명을 고려한 일반적인 illumination을 말한다. ambient light은 장면의 다양한 개체에서 반사된 빛을 설명한다. ambient light가 scene에서 많이 반사됨으로써, 모든 방향에서 표면 점에 도달하고 표면 점으로부터의 반사도 모든 방향에서 동일한 강도로 산란된다.6-6-4. Emissive Termemissive term이란?▪ Phong model의 마지막 term인 emissive term은 표면 자체에서 방출되는 빛의 양을 말한다.아래 그림에서 왼쪽은 emmsive가 없고, 오른쪽은 emmisive가 활성화된 상태이다.6-7. Phong Lighting ModelPhongmodel은 위에서 설명한 4개의 항을 합산하여 만들어진다.6-8. Per-pixel Lighting물체의 표면에 있는 두 점을 생각해 보자. 각 점은 개별의 픽셀을 구성한다. l, n, r 및 v를 사용하여 pixel shader의 lighting을 계산해보자.▪ directional light을 가정한다면, 모든 표면 점에 대해 l은 일정하다. 픽셀 셰이더에 constant buffer로 제공됩니다.▪ 반면, n, r, v는 물체의 표면에 따라 다르다. 픽셀 셰이더가 실행할 때마다 n과 v의 고유한 쌍이 주어지며, 픽셀 셰이더는 r(r = 2n(n·l)-l)을 계산한다.Normal for each pixel▪ l이 world space 벡터이므로 n도 world space에서 정의되어야 한다.▪ 이를 위해 vertex shader는 각 vertex의 object-space normal을 world-transform하고 rasterization 단계에 world-space normal을 전달한다.▪ rasterization 단계에서 vertex normal은 각 픽셀에 대해 n을 제공하기 위해 보간된다.▪ 각각 별개의 픽셀을 구성하는 것으로 가정되는 a와 b에 rasterizer는 n1과 n2를 보간하여 법선 na와 nb를 할당한다.View vector for each pixel▪ 픽셀 a 및 b에 대해 각각 va 및 vb로 표시된 world-space view 벡터도 필요로 한다.▪ 이를 위해 vertex shader는 각 vertex의 object-space 위치를 world-space으로 변환하여 worrld-space에서 정의된 카메라 위치인 EYE에 연결한다.▪ 정점별 worrld-space view 벡터는 v1과 v2이다.▪ 이들은 rasterization단계로 전달되고 보간되어 va 및 vb를 생성하게 된다.최정적으로 픽셀 셰이더는 픽셀 색상을 결정한다.▪ n과 v가 픽셀 셰이더에 입력으로 제공되고 l이 Direct3D 프로그램에 의해 constant buffer로 제공되면 픽셀 셰이더는 먼저 reflection 벡터, 즉 r=2n(n·l)-l을 계산하고 마지막으로 Phongmodel을 구현한다.▪ l, n, r, v는 모두 world space에 정의되어 있음을 주의한다." }, { "title": "그래픽스 실전3", "url": "/posts/graphics6/", "categories": "그래픽스", "tags": "graphics", "date": "2022-08-06 15:44:34 +0900", "snippet": "지난 포스트에서 이어집니다. Pixel shader의 경우 이번 포스트에서 먼저 Image Texturing에 대한 내용을 다루고, 다음 포스트에서 Lighting에 대하여 알아보도록 하겠습니다.이 포스트는 경희대학교 게임 그래픽 프로그래밍 수업자료를 바탕으로 합니다.6. Pixel Shaderrasterizer에 의해 생성된 각 픽셀은 일반적으로 법선 벡터와 텍스처 좌표를 포함한다. 이러한 특성을 사용하여 픽셀 셰이더는 각 픽셀의 색상을 결정한다.6-1. Image textring물체의 표면에 이미지를 붙여넣는 것으로 이해하면 된다.▪ Image textring은 다양한 텍스처링 방법 중 가장 간단한 방법이다.▪ 텍스처는 일반적으로 texels(텍스처 요소)의 2차원 배열로 표현된다.▪ texel의 위치는 좌표의 중심으로 나타낼 수 있다.• 예시로 아래 그림을 보자. 왼쪽 하단 모서리 texel은 (0.5, 0.5)에 있고 그 오른쪽의 texel은 (1.5, 0.5)에 있다.텍스처링을 위해 모델링 단계에서 폴리곤 메쉬의 각 꼭짓점에 텍스처 좌표(s, t)를 할당한다.▪ rasterizer는 픽셀에 대해 보간한다.▪ 정규화된 텍스처 좌표(s, t)는 텍스처 공간에 투영된다.s와 t가 0에서 1 사이가 되도록 텍스처 좌표를 정규화하는 것이 일반적이다. 정규화된 텍스처 좌표는 특정 텍스처 해상도에 의존하지 않으며, 다양한 텍스처에 자유롭게 연결할 수 있다.또한 텍스처 좌표를 변경하지 않고 서로 다른 해상도의 여러 이미지를 표면에 붙일 수도 있다.6-2. Parameterization▪ 폴리곤 메쉬의 정점에 텍스처 좌표를 할당한다.▪ 이 과정을 surface parameterization 또는 간단히 parameterization라고 한다. 일반적으로 parameterization는 3D표면을 2D평면 도메인으로 펼쳐야 하는 것을 필요로 하기에 사용된다.6-3. Patch, Chart and Atlas▪ 복잡한 폴리곤 메쉬는 일반적으로 패치가 개별적으로 펼쳐지도록 여러 패치로 세분화된다(예: 얼굴, 몸, 팔 등).▪ 각 패치가 펼쳐지고 parameterization된다. 그런 다음 아티스트는 각 패치에 대한 이미지를 그린다. 이 패치의 이미지를 차트라고 한다.▪ 여러 차트는 일반적으로 아틀라스라고 하는 텍스처로 패킹되고 배열된다.6-4. Texture Wrapping텍스처 좌표(s,t)가 반드시 [0,1] 범위에 있는 것은 아니다. 텍스처 래핑 모드는 범위를 벗어난 좌표(s,t)를 처리합니다.▪ Clamp-to-Edge: 범위를 벗어난 좌표는 가장자리 색상으로 렌더링된다.▪ Repeat: 텍스처가 모든 integer junction에서 타일링된다.▪ Mirrored-Repaet: 텍스처가 모든 integer junction에서 미러링되거나 반사된다.6-5. Texture Filteringquad를 고려하자. 화면의 (x, y)에 있는 각 픽셀에 대해 텍스처 좌표(s, t)가 텍스처 공간의 (s’, t’)에 투영된다.▪ (s’, t’)는 대부분의 경우 부동 소수점 값이다.▪ 따라서 (s’, t’) 주변의 텍셀이 샘플링된다. 이 샘플링 프로세스를 텍스처 필터링이라고 한다.Magnification▪ 확대의 경우, 화면 공간 쿼드는 이미지 텍스처보다 크게 나타날 수 있으므로 텍스처가 쿼드에 맞도록 확대된다.▪ 텍셀보다 픽셀이 많다.Minification▪ 축소의 경우, 화면 공간 쿼드는 이미지 텍스처보다 작게 나타날 수 있으며 텍스처가 축소된다.▪ 텍셀보다 픽셀 수가 적다.차례로 좀 더 자세히 살펴보자.확대의 2가지 방법옵션 1: 가장 가까운 점 샘플링 (Nearest point sampling)▪ 픽셀 블록은 단일 텍셀에 매핑될 수 있다.▪ 따라서 인접한 픽셀 블록이 한 텍셀에서 다음 텍셀로 갑자기 변경되어 뭉툭한 이미지가 생성되는 경우가 많다.옵션 2: 쌍선형 보간 (Bilinear interpolation)▪ 최근 접점 샘플링을 선호하는 이유는 최종 결과가 이미지의 뭉침 현상이 훨씬 덜할 뿐만 아니라 그래픽 하드웨어가 일반적으로 쌍선형 보간(bilinear interpolation)에 최적화되어 있기 때문이다.다음은 축소의 방법이다.Aliasing in minification▪ minification의 경우 픽셀은 텍스처 공간에 드문드문 투영된다.▪ checkerboard image texture를 생각해보자.• 모든 픽셀이 짙은 회색 텍셀로 둘러싸여 있으면 질감이 있는 쿼드가 짙은 회색으로 나타난다.• 모든 픽셀이 밝은 회색 텍셀로 둘러싸여 있으면 텍스처 쿼드가 밝은 회색으로 나타난다.▪ 이 문제가 aliasing의 instance이다.Mipmap▪ minification에서 확인되는 aliasing 문제는 픽셀보다 텍셀이 더 많기 때문에 발생한다. 픽셀은 텍스처 공간에서 크게 점프하여 텍스처링에 관여하지 않는 많은 텍셀을 남긴다.▪ 이에 대한 해결책은 텍셀 수가 픽셀 수에 최대한 가깝게 되도록 텍셀 수를 줄이는 것이다. 따라서 텍스처 크기를 줄이기 위해 다운 샘플링이 채택되었다.▪ 2lx2l 해상도의 원본 텍스처가 주어지면 원본 텍스처가 레벨 0에 위치하는 (l+ 1) 레벨의 피라미드가 구성된다.▪ 이 피라미드를 밉맵이라고 한다.▪ 필터링할 정도를 level of detail(LOD)이라고 하며 λ로 표시한다. texelcount가 픽셀 수에 가까운 레벨을 찾는다.레벨 1 예시▪ 픽셀은 화면의 한 영역을 덮는다.▪ 간단하게, 면적을 정사각형으로 둔다. 그러면 텍스처 공간에 대한 픽셀의 투영은 점이 아니라 (s’, t’)를 중심으로 하는 영역이 된다. 투영된 영역을 픽셀의 footprint라고 한다.▪ 이 예에서, 쿼드와 레벨 1 텍스처는 동일한 크기를 갖는다. 픽셀의 footprint는 레벨 0에서 2 x 2 텍셀을 포함하지만 레벨 1에서 단일 텍셀을 덮는다.▪ 픽셀 footprint가 레벨 0 텍스처의 m × m 텍셀을 덮을 때 λ는 log2m으로 설정된다.레벨 2 예시▪ 이 예에서는 screen-space quad와 level-2 texture의 크기가 동일하다. 픽셀의 footprint는 레벨 2 텍스처에서 단일 텍셀을 덮고 필터링된다.▪ 이번 예제와 이전 예제에서 모든 텍셀이 필터링과 관련되어 있음을 기억하자.레벨 1.585 예시▪다음 예에서 λ = log23 ≒1.585이므로 레벨 1과 2를 확인할 수 있다. ▪ 옵션 1: 가장 가까운 레벨 선택. l = round(λ).▪ 옵션 2: 두 레벨을 모두 취하고 필터링 결과를 선형으로 보간. (bilinear interpolation)6-6. Pixel shader픽셀 셰이더에 대한 입력▪ pixel: vertex shader에 의해 생성된 per-vertex 출력 변수는 per-pixel 변수를 결정하기 위해 보간된다.▪ Constant buffer : 픽셀 셰이더에서 사용할 전역 버퍼.출력: 하나 이상의 픽셀 색상.픽셀 셰이더는 각 픽셀에 대해 한 번 실행되며, 각 픽셀은 독립적으로 처리된다.Pixel shader는 다음 포스트에서 Lighting으로 계속 이어집니다." }, { "title": "그래픽스 실전2", "url": "/posts/graphics5/", "categories": "그래픽스", "tags": "graphics", "date": "2022-07-16 15:07:01 +0900", "snippet": "지난 포스트에서 이어집니다.이 포스트는 경희대학교 게임 그래픽 프로그래밍 수업자료를 바탕으로 합니다.4. Geometry ShaderGPU에 의해 수행되는 셰이더 프로그램 중 하나로 HLSL, GLSL 등으로 작성된다. Primitives의 처리를 제어하며 vertex shader와 fragment shader단계 사이에 위치한다. 즉 점이나 선, 삼각형 등의 도형을 생성할 수 있는 기능이 있으며, 주로 테셀레이션이나 그림자 효과, 큐브 맵을 한번의 처리로 렌더링하는 데에 사용된다.각 삼각형의 세 꼭짓점이 geometry shader에 입력되고 geometry shader가 Primitives 목록을 출력한다. vertex를 파괴하거나 만들 수 없는 vertex shader와 달리 geometry shader의 주요 장점은 geometry를 생성하거나 파괴할 수 있다는 것이다. 이를 통해 GPU에서 몇 가지 흥미로운 효과를 구현할 수 있는데, 예를 들어 입력 Primitive를 하나 이상의 다른 Primitives로 확장하거나, geometry shader가 어떤 조건에 기초하여 Primitive를 출력하지 않도록 선택할 수 있다.5. RasterizerRasterizer는 view에 없는 Primitives를 클립하고, Pixel shader 단계에 대한 Primitives를 준비하며, Pixel shader를 호출하는 방법을 결정한다. Rasterizer 단계에서는 실시간 3D 그래픽을 표시하기 위해 벡터 정보(shapes 또는 primitives로 구성됨)를 래스터 이미지(pixels로 구성)로 변환한다.Rasterizer 단계에 도달하는 vertex는 몇 가지 고정된 vertex 후처리 단계를 거친다.• Primitive Clipping• Perspective Division• Viewport Transform즉, Resterization는 각 개별 primitive가 primitive의 샘플 적용 범위를 기반으로 Fragments(pixel shader)라고 하는 2차원 이미지 요소로 분할되는 프로세스인 것이다.이 파트의 내용을 이해하기 위해서는, 먼저 클리핑에 대한 개념을 알아야 한다.clipping은 clip space에서 이루어지지만 직관적인 이해를 위해 카메라 공간에서의 개념을 알아보겠다.▪ 삼각형 t1은 view frustum에서 완전히 벗어나 컬링된다.▪ 삼각형 t2가 완전히 안쪽에 있고 그대로 다음 단계로 넘어간다.▪ 삼각형 t3은 view frustum와 교차하여 잘린다.primitives가 클리핑 볼륨에 잘리는 방법은 기본 primitives 유형에 따라 다르다.▪ Points : 포인트가 클리핑 볼륨 외부에 있으면 폐기된다. 점이 1픽셀보다 크면 점의 중심(SV_POSITION)을 확인한다.▪ Lines : 선이 부분적으로 볼륨 외부에 있는 경우 새로운 vertex가 생성되어 클리핑 볼륨의 경계가 있는 끝점에 추가된다.▪ Triangles : 삼각형이 viewing volume에 잘려지면 꼭짓점이 잘라내는 볼륨의 경계에 있는 적절한 삼각형이 생성된다.5-1. Viewport Transform큐브 형태의 공간에서 모니터 화면으로 넘어간다. 컴퓨터 화면의 창은 자체 창 공간 또는 화면 공간과 연결된다.\t▪ viewport는 장면이 투영되는 화면 공간 직사각형을 정의한다.\t▪ 전체 영역의 창일 필요는 없지만, 창의 하위 영역일 수 있다.실제로 viewport는 다음과 같은 매개변수를 사용하여 3D 공간에서 정의된다.\t▪ minX, minY, 너비, 높이, minZ, maxZ.이를 설정하기 위해 D3D11_VIEWPORT 구조를 초기화한다.\t▪vp.TopLeftX= minX, vp.TopLeftY= minY+ h, vp.Width= w, vp.Height= h\t▪vp.MinDepth= minZ, vp.MaxDepth= maxZViewport Transform은 vertex 위치를 NDC spacae에서 windoww space으로 변환합니다.▪ scaling과 translation의 combination이다.▪ DirectX에서 NDC 공간의 크기는 2×2×1인 반면 OpenGL에서는 2×2×2임을 기억하자.대부분의 응용 프로그램에서 뷰포트는 전체 창(모니터 화면)을 차지한다.▪ minX = 0, minY = 0.▪ minZ = 0, maxZ = 1.5-2. Face cullingPrimitive에는 vertices의 순서로 정의되는 특정 면이 있다.▪ 카메라 시점에서 멀어지는 Primitives를 back faces라고 한다.▪ 카메라를 향하는 Primitives를 front faces라고 한다.▪ Face culling을 사용하면 비싼 Rasterazation 및 Fragment shader 작업 전에 보이지 않는 기본 요소(back faces)를 제거할 수 있다. =&gt; 카메라에 보이지 않는 부분은 렌더링 하지 않는다.xy 평면에 보편적인 투영선을 따라 삼각형을 개념적으로 투영하자. CW 감기 순서의 2D 삼각형은 back face이고 CCW 감기 순서의 2D 삼각형은 front face이다.[determinant 검사 (ad – bc가 음수면 back face, 양수면 front face)]아래 행렬식을 계산해보자. 여기서 첫 번째 행은 v1과 v2를 연결하는 2D 벡터를 나타내고, 두 번째 행은 v1과 v3을 연결하는 2D 벡터를 나타낸다.▪ If negative, CW and so back-face.▪ If it is positive, CCW and so front-face.▪ If 0, edge-on face.back face가 항상 컬링되는 것은 아나다.▪ 속이 빈 반투명 구를 렌더링하는 것을 생각해보자. bakc faces가 front faces을 통해 표시되도록 하려면 어떤 면도 컬링되어서는 안 됨을 알 수 있다.DirectX의 Back face culling▪ 기본적으로 face culling 활성화되어 있다.5-3. Edge EquationPrimitives 래스터화는 두 부분으로 구성된다.▪ 1. 윈도우 좌표에서 정수 그리드의 어느 사각형이 프리미티브에 의해 점유되는지 결정.▪ 2. 그리드의 각 사각형에 색상 및 깊이 값 할당.이를 바탕으로 다음 내용을 이해한다.▪ 2D 평면을 두 부분으로 나누는 선이 있다고 가정하자. Edge Equation은 주어진 점이 이 선의 어느 쪽에 있는지 테스트한다.• 점이 왼쪽에 있을 때: 음수.• 점이 오른쪽에 있을 때: 양수.• 점이 선 위에 있을 때: 숫자 0.Edge Equation은 픽셀이 삼각형과 겹치는지 여부를 테스트한다.▪ 삼각형의 모서리를 2차원 평면을 나누는 선으로 볼 수 있다.▪ 삼각형의 첫 번째 변(꼭짓점 v0과 v1으로 정의됨)에 변 방정식을 적용해 보자.▪ 이 예에서 픽셀은 선의 오른쪽에 있다.▪ 다른 두 변에도 같은 방정식을 적용해 보자.Edge Equation은 픽셀이 삼각형과 겹치는지 여부를 테스트한다. 아래 그림을 보자.▪ 우리는 edge 함수가 삼각형의 세 모서리 모두에 대해 양수를 반환한다는 것을 확인할 수 있다.▪ 점이 삼각형 안에 있는 경우 점은 삼각형의 세 모서리 모두의 오른쪽에 있다.▪ 이는 edge 함수가 세 개의 edge 모두에 대해 양수를 반환함을 의미한다.Edge Equation의 정의를 살펴보자.▪ E(P, v0, v1) = (P.x–v0.x)·(v1.y –v0.y) -(P.y–v0.y)·(v1.x –v0.x)이 방정식은 2D 벡터(P-v0) 및 (v1-v0)의 구성요소에 의해 정의된 2×2 행렬의 행렬식 계산과 동일하다.이 방정식은 수학에서 벡터 A = (P-v0), B = (v1-v0) 간의 외적 크기와 동일하다.▪ 모든 3D 점(p, v0, v1)이 z값이 0이라고 가정해 보자.▪ 그러면 다음과 같이 외적을 계산할 수 있다.이 방정식은 수학에서 벡터 A = (P-v0), B = (v1-v0) 간의 외적 크기와 동일하다.▪ (0, 0, A.x · B.y – A.y · B.x)에서 두 벡터의 외적 크기는 A.x · B.y – A.y · B.x임을 알 수 있다.▪ 두 벡터의 외적의 크기는 오른쪽 그림과 같이 평행사변형의 넓이로 해석할 수 있으므로 위의 공식은 아래 그림의 결과와 같다는 것을 알 수 있다(평행사변형 공식).▪ 따라서 edge 방정식은 0 &lt; θ &lt; 180이면 양수 값을 반환하고 180 &lt; θ &lt; 360이면 음수 값을 반환한다.5-4. Assigning Attributes for Fragments삼각형(v0v1v2)과 겹치는 점(p)의 속성(색상, 깊이, 법선 등)은 삼각형 꼭짓점의 속성을 보간하여 얻을 수 있다.▪ v0, v1, v2의 색상이 Cv0, Cv1, Cv2라고 가정해보자.▪ 그러면 p∈△V0,V1,V2에 대해 무게중심 좌표 P = λ0 * v0 + λ1 * v1 + λ2 * V2, λ0+λ1+λ2=1 로 p 의 색상을 계산할 수 있다.▪ 위치, 깊이, 법선도 이 방법으로 계산할 수 있다.무게 중심 좌표(λ0, λ1, λ2)의 가중치는 삼각형(T0, T1, T2)의 면적에 비례한다. Edge Equation은 평행사변형의 면적을 반환하기 때문에, 아래와 같이 계산한다.▪ T0은 0.5 * E(p, v1, v2)로 계산할 수 있다.▪ T1은 0.5 * E(p, v2, v0)로 계산할 수 있다.▪ T2는 0.5 * E(p, v0, v1)로 계산할 수 있다.▪ 삼각형 v0v1v2의 넓이는 0.5 * E(v2, v0, v1)로 계산할 수 있습니다.계산 공식은 아래와 같다.Top-Left 규칙픽셀이 두 삼각형이 공유하는 edge에 있을 때 두 번 처리되는 것을 방지하기 위해 어느 삼각형에 속하는지 결정해야 한다. 이를 어떻게 처리하는지 알아보자.▪ 그림을 보면 삼각형은 왼쪽, 오른쪽, 위쪽 또는 아래쪽 edge를 가질 수 있다.▪ 아래 그림에서 t1은 왼쪽 edge 2개와 오른쪽 edge 1개, t2는 왼쪽 edge 1개, 오른쪽 edge 1개, 아래쪽 edge 1개, t3은 왼쪽 edge 1개, 오른쪽 edge 1개, 위쪽 edge 1개를 가진다.▪ Direct3D는 픽셀이 삼각형의 위쪽 또는 왼쪽 edge에 있는 경우 그 삼각형에 속한다고 선언하는 top-left 규칙을 채택한다.아래 그림을 보며 정확히 이해해보자." }, { "title": "그래픽스 실전1", "url": "/posts/graphics4/", "categories": "그래픽스", "tags": "graphics", "date": "2022-07-16 13:02:37 +0900", "snippet": "이번 포스트부터 직접적으로 그래픽스를 알아보겠습니다. 이전 3개의 기본 개념 포스트는 이 번 포스트를 쉽게 이해하기 위한 빌드업 과정이었다고 생각해도 좋을 만큼 아마 오늘 내용이 가장 중요할 것입니다.이 포스트는 경희대학교 게임 그래픽 프로그래밍 수업자료를 바탕으로 합니다.1. GPU pipeline그래픽스 전체를 관통하는 핵심적인 구조이다. 위 사진의 구조는 반드시 알고 있어야 앞으로의 그래픽스 지식을 이해할 수 있다. 그래픽스 포스트에서는 이 중 3, 4, 5, 마지막 단계를 제외한 나머지 단계를 모두 알아볼 것이다.GPU에서 렌더링은 한 단계의 출력이 다음 단계의 입력으로 사용되는 파이프라인 아키텍처에서 수행된다. 즉 위의 사진은 각 단계를 거치며 보여주는 입력에서 출력으로의 데이터 흐름이다.▪ rendering pipeline의 shader는 program이라고 생각하면 이해하기 쉽다.▪ 반면 Input-Assembly, Tessellation, Rasterization, Output-Merger Operation은 고정된 기능을 수행하는 hard-wired 단계이다.2. Input-Assembly파이프라인의 첫 단계. Input-Assembly는 primitives 또는 patches를 생성한다.• 정점 정보(ex: position) 및 기하학적 기본 설정(ex: D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST – gpu에서 받은 수많은 버텍스 정보를 3개씩 나누어 삼각형으로 인식하도록 함)을 사용한다.• 입력이 6개의 꼭짓점의 시퀀스이고 기본 설정이 D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST라고 가정하자. 그렇다면 출력은 두 개의 삼각형이 된다.3. Vertex Shader중요) per vertex -&gt; clip space로 보낸다. 즉 스페이스 체인지가 일어난다.vertex specifications은 Vertex shaders의 입력으로 사용된다.▪ Vertex shaders는 정점마다 한 번씩 수행된다.▪ Vertex shader는 각 정점의 최종 위치를 계산하기 위해 일련의 변환을 적용한다.3-1. World Transformworld transform의 역할은 각각의 object space에 정의된 모든 objects를 world space이라는 단일 환경으로 조합하는 것이다.3-2. View Transform카메라를 기준으로 무언가를 찍는다고 생각하면 된다.카메라도 객체이기 때문에 world space에서 정의된다. (3개의 기저를 필요로 한다 : xyz) world space의 카메라 포즈 사양은 다음과 같다.▪ EYE: 카메라 위치▪ AT: 카메라가 향하는 기준점▪ UP: 카메라 상단이 가리키는 위치(view up vector), 대부분의 경우 UP은 월드 공간의 세로축인 y축으로 설정된다.위 요소로 카메라 공간인 {u, v, n, EYE}를 생성할 수 있다. {u, v, n}은 직교기저(orthonorma basis)임을 기억하자.eye-at으로 n벡터를 구하고, n을 up벡터와 직교로 u를 구하고, n과 u로 v를 구한다.예제와 함께 다시 살펴보자.점에는 별개의 공간에서 서로 다른 좌표가 지정된다.▪ camera space{u, v, n, EYE}와 world space{e1, e2, e3, O}.▪ 찻주전자 입의 끝부분은 world space의 좌표(10, 2, 0)를 가진다.▪ 찻주전자 입의 끝부분은 camera space에서 좌표(0, 0, -10)를 가진다.▪ 모든 world space 객체를 찻주전자의 입 끝과 같이 camera space 측면에서 새로 정의할 수 있다면 렌더링 알고리즘 개발이 훨씬 쉬워질 것이다.▪ 일반적으로 이를 space transform이라고 한다. world space{e1, e2, e3, O}에서 camera space{u, v, n, EYE}로의 공간 변경이 view transform인 것.world space는 camera space {u, v, n, EYE}를 세계 공간 {e1, e2, e3, O}에 중첩하는 과정으로 직관적으로 설명할 수 있다.▪ 첫째, EYE는 world space의 기원으로 translation된다.▪ world space와 camera space는 이제 translation으로 인해 원점을 공유한다.그런 다음 {u, v, n}을 {e1, e2, e3}으로 변환하는 회전 R이 필요하다. 그래픽스 기본 개념3에서 나온 rotation을 기억해보자.여기서 햇갈리기 전에, 위 개념에서 방향은 어떻게 정하는지 좀 더 확실히 정리하고 넘어가자.Right-hand system Left-hand system을 떠올려 보자.첫 번째 포스트에서 OpenGL은 RHS를 사용하고 Direct3D는 LHS를 사용한다는 것을 적어두었다. 이 차이를 알고 아래 내용을 보자. RHS 예시▪ 카메라의 위치(EYE) = (0, 0, 0)이고 카메라의 시야 방향(AT)이 (0, 0, -1)이라고 가정▪ 카메라가 이미지를 캡처하면 아래와 같을 것이다. LHS 예시▪ 객체 및 카메라 매개변수를 LHS로 이식해 보자.▪ 꼭짓점의 좌표와 view의 방향은 바뀌지 않고 이미지가 뒤집힌 것을 알 수 있다.위 차이를 어떻게 보완해 줄 수 있을까?▪ 위와 같이 반사적으로 나타나는 이미지 결과를 피하기 위해 객체와 뷰 매개변수의 z 좌표를 모두 무효화해야 한다. : z-negation▪ z-negation은 개념적으로 z-축 반전과 동일하다.즉, z축에 –1을 곱하는 것이다. (아래 그림에서 5에 –를 곱했다)3-3. Project Transform이전 과정에서의 eye, at, up은 카메라의 외부 파라미터이다. 카메라의 내부를 정의하는 것은 카메라 렌즈의 줌을 제어하는 기능 등을 말한다. 이를 살펴보자.frustm과 culling에 대하여 알아보겠다.View Frustum▪ 카메라는 시야가 제한되어 있기 때문에, 장면의 모든 물체를 캡처할 수 없다.▪ scene에서 보이는 영역을 view frustum(view volume)라고 한다.위 그림에서,▪ view frustum parameters, fovy, aspect, n, f는 잘린 피라미드를 정의한다.▪ fovy는 y축에 대한 시야를 지정한다.▪ aspect는 뷰 프러스텀의 종횡비를 나타낸다.View frustum culling▪ out-of-frustum object는 최종 이미지에 기여하지 않으며 일반적으로 GPU 파이프라인에 들어가기 전에 폐기된다.▪ 이 제거 과정은 GPU의 연산 능력을 절약한다.Clipping▪ polygon이 view frustum의 경계와 교차하면 경계를 기준으로 잘리고 view frustum 내부 부분만 처리되어 표시된다. (이는 래스터화 단계에서 수행된다)Clip space▪ pyramidal view frustum은 클리핑에 사용되지 않는다.▪ 대신, view frustum을 원점을 중심으로 축 정렬된 2×2×2 크기의 큐브로 변형하는 transform이 사용된다. 이를 projection transform이라고 한다.▪ camera space objects는 projection transformed된 다음 큐브에 대해 잘리게 된다.▪ projection-transformed 오브젝트는 clip space에 있다고 하며, 이는 이름이 변경된 카메라 공간일 뿐이다.View frustum to cube▪ view frustum은 마치 projection line의 연필(의 수렴하는 부분)로 볼 수 있다. 카메라(EYE)가 위치한 원점에 선이 수렴된다.▪ 투영선의 모든 3D 포인트는 투영된 이미지의 단일 2D 포인트에 매핑된다. 멀리 있는 물체가 작게 보이는 원근 투영(perspective projection) 효과를 가져온다.▪ projection transform은 projection line이 z축과 평행이 되도록 한다. 따라서 viewing은 보편적인 투영선을 따라 수행된다. projection transform은 “3D 공간 내에서” 원근 투영 효과를 가져온다." }, { "title": "Python 머신러닝을 이용한 댓글 크롤링 및 긍정 부정 판별 시스템 개요", "url": "/posts/memo4/", "categories": "개발 메모", "tags": "memo, NLP", "date": "2022-07-15 19:08:00 +0900", "snippet": "1학년 학부 연구생 시절 진행했던 베스트 댓글 알고리즘 개편에 대한 개요이다. 임시블로그에 있던 글을 여기 기록용으로 남겨둔다.프로그래밍에 대해 아무것도 모르던 새내기 시절 머신러닝을 해보겠다 고군분투 하던 글 들을 지금 다시 보니, 정말 민망한 흔적들이 많이 보인다…접근개인 연구 주제로 댓글의 긍적적, 부정적 척도를 판별하고 분석하는 프로그램을 만들어보고자 하였다.궁극적으로 지향하는 바는 댓글의 편향성 및 신뢰성 측정을 통한 베스트 댓글 알고리즘 개편이다. Reorganization of the best comment algorithm by measuring the bias and reliability of comments요약문베댓 저널리즘이란, 베스트 댓글이 여론을 주도하는 현상을 가리키는 용어로 댓글의 영향력이 커진 것을 반영하는 신조어이다. 뉴스의 댓글 기능은 애초 기사에 관한 외부 의견을 모으고 여론을 수렴하는 장치로 출발했다. 그런데 현재는 ‘뉴스는 안 읽고 댓글만 읽는다’는 말이 나올 정도로 댓글은 여론을 조종하는 거대 장치가 되었다. 이 점을 악용하여 특정 집단이 각종 웹사이트나 SNS에서 댓글을 장악하여 여론을 조정하는 사태가 발생하고 있다. 노출빈도가 높고 영향력이 강력한 베스트 댓글 제도는, 단순추천제로 이루어지기에 쉽게 조작될 수 있다. 본 연구는 올바른 인터넷 댓글문화와 정당한 여론 조성을 위하여, 베스트 댓글 알고리즘을 개편하기 위함에 있다. 댓글의 편향성을 측정하는 알고리즘을 설계하여, 가장 편향성이 적고 신뢰감을 주는 댓글을 베스트 댓글로 만드는 인공지능 프로그램을 개발한다.위 그림은 본 연구를 위한 프로그램을 제작하는 과정을 나타낸 것이다. 뉴스기사의 댓글을 크롤링하여 정리한 후, 편향성 측정 프로그램을 통해 베스트 댓글의 알고리즘을 바꾼다. 레이블에 따라 재배치된 베스트 댓글을 대중들에게 공개하여 이전과 비교하며 댓글에 대한 인식을 조사한다.연구의 필요성과 타당성을 입증하기 위해, 베스트 댓글의 알고리즘에 대한 설문조사를 실시하였다. 이를 위해 「생명윤리법 관련 온라인 교육과정」을 수료하였다. (교육과정 : 인간대상연구 및 인체유래물연구)테스트 데이터는 네이버 댓글에서 가져오도록 하였다.이 시스템의 첫 시작을 위해 구현해야할 기능은 크게 두가지이다.첫 번째는 뉴스 기사 속의 네이버 댓글을 크롤링 해서 가져오는 것이고, 두 번째는 TextBlob을 사용하여 머신러닝 기반의 파이썬 텍스트 분류기를 생성하는 것이다.크롤링을 위해 BeautifulSoup를 import한다.https://apis.naver.com/commentBox/cbox/web_neo_list_jsonp.json?ticket=news&amp;templateId=default_society&amp;pool=cbox5&amp;_callback=jQuery1707138182064460843_1523512042464&amp;lang=ko&amp;country=&amp;objectId=news”+oid+”%2C”+aid+”&amp;categoryId=&amp;pageSize=20&amp;indexSize=10&amp;groupId=&amp;listType=OBJECT&amp;pageType=more&amp;page=”+str(page)+”&amp;refresh=false&amp;sort=FAVORITE위 API는 네이버 댓글을 추천순으로 긁어올 수 있는 네이버의 댓글 API URL이다.r=requests.get(comments_url, headers=header) cont=BeautifulSoup(r.content,\"html.parser\") total_comm=str(cont).split('comment\":')[1].split(\",\")[0] match=re.findall('\"contents\":([^\\*]*),\"userIdNo\"', str(cont))댓글을 파싱하는 메인 코드이다. comments_url에 댓글 api url을 담는다. 종종 유용하게 쓰일 듯 하니 기록해두자.댓글을 크롤링하면 결과가 출력된다.이제 이렇게 크롤링한 댓글을 텍스트화 하여 긍정부정 판별 프로그램에 넣는다. 판별방법은 미리 입력된 데이터를 기반으로 하는 머신러닝에 기반하였다.분석을 위해 NaiveBayesClassifier와 TextBlob을 import 한다.기존의 학습데이터를 train에 넣고, NaiveBayesClassifier(train)를 cl에 넣어주었다.크롤링한 댓글들은, 기존의 train 학습자료를 바탕으로 긍정과 부정의 척도가 a : b 비율로 나타내어진다.유사한 방법으로 train데이터에서 편향성을 학습시켜, 댓글의 편향성 정도를 판별할 수 있다.개선 사항이 프로그램의 정확성을 높이기 위해 생각한 방법을 적어본다면,첫번째는 데이터셋을 늘리는 것이다. 현재 이 프로그램은 데이터셋에 존재하지 않는, 새롭게 인식하는 단어의 판별이 매우 불안정하다. 레이블 값에서 가져올 판별대상이 없으므로 엉뚱한 결과가 출력되는 것이다. 머신러닝에 기반한 본 시스템은 데이터셋이 많아질수록 학습하는 데이터값이 늘어나므로, 데이터셋을 많이 구축해야한다.두번째는 자연어처리를 사용하여, 형태소 분석을 하는 것이다. 한글은 매우 다양한 맺음말을 가지고 있다. 이 프로그램은 문장 자체를 전부 받아들여 문장내의 단어로 편향성을 판별하므로, 맺음말이 다른 경우 다른 단어로 인식하여 각각 다른 결과를 출력한다. (ex. 힘듦, 힘들다, 힘들었음) 따라서 문장을 학습하는 것에서 더 깊이 들어가, 문장 내의 형태소를 분석하여 판별하면 맺음말에 따라 다르게 판별하는 경우가 사라지므로 정확성이 올라갈 것이다. (ex. ‘나쁘다’를 학습하는 것이 아니라 ‘나ㅃ-‘ + [종성 또는 어미]로 분석하여 학습한다)" }, { "title": "그래픽스 기본 개념3", "url": "/posts/graphics3/", "categories": "그래픽스", "tags": "graphics", "date": "2022-07-10 00:25:26 +0900", "snippet": "저번 포스트 내용에서 이어집니다. 기본 개념은 이번을 마지막으로 하며, 다음 포스트 부터는 본격적으로 그래픽스 내용을 담게 됩니다.이 포스트는 경희대학교 게임 그래픽 프로그래밍 수업자료를 바탕으로 합니다.1. Affine transformAffine에 대해서는, 수학적 계산 보다 기본적인 개념과 역할만 간단하게 알아본다.두 Affine space U, V 간 Collinear point을 유지하는 Isomorphism으로 정의된다.한 벡터공간을 다른 벡터공간으로 대응시키는 변환으로, 선형 변환과 평행 이동 변환의 합성으로 이루어져 있다.▪ 3차원 공간은 Affine space이다.▪ Affine transform이란, 점들을 변환하는 것이다.▪ Affine transform은 직선을 보존하는 특징을 가지고 있다. 하지만 각도, 직선의 방향, 두 점 사이의 거리는 보존하지 않는다.▪ 면적을 보존하지는 않지만, 면적이 변하는 배수는 일정하다.▪ 주로 기하학적 왜곡이나 형태 변형을 보정하는데 사용된다.ex) 위성 영상에서의 광각 렌즈 왜곡, 파노라마 스티칭, 영상 정합 보정▪ 얼마나 많은 affine 행렬이 주어졌던지 간에 모두 행렬로 결합될 수 있다.이와 반대로, Non-Affine transform은 다음과 같을 때 사용된다.▪ 변환 후 공간의 평행선이 보존되지 않는 경우(ex.원근 투영)▪ 선 사이의 중간 점이 보존되지 않는 경우(축을 따라 비선형 크기 조정)2. Rigid motion (scaling을 제외한, rotation과 translation이 적용되는 모션)▪ 결합된 affine 행렬을 객체에 적용하면 객체의 포즈(위치 + 방향)가 변경되지만 모양은 변경되지 않는다.▪ 이런 의미에서의 변환을 rigid-bodymotion 또는 단순히 rigid motion이라고 명명한다.▪ 얼마나 많은 회전과 평행 이동이 결합되었는지에 상관없이 결과 행렬은 [R|t] 구조이다.▪ R은 translation을 포함하지 않는 combined rotation을 나타낸다.▪ t는 rotation을 포함하는 combined translation 을 나타낸다.2. 3D Scaling스케일링 계수 sx,sy, sz를 사용하여 3D 스케일링을 표현한다.모든 스케일링 계수가 동일하면 스케일링이 uniform하고, 그렇지 않으면 non-uniform 하다고 한다.3. 3D Rotation회전 중심이 필요한 2D 회전과 달리 3D 회전은 회전 축이 필요하다.▪ x축(Rx), y축(Ry), z축(Rz)에 대한 3차원 회전을 생각해 보자▪ 다음 예는 Rz에 대한 회전을 보여준다. (z축 회전)▪ x’ = x.▪ 오른손의 엄지손가락이 회전축과 일치할 때, 다른 손가락은 y축에서 z축으로 말림을 기억하자.▪ Rz로 돌아와서 x축에서 y축으로 손가락이 말리는 것을 보면 알 수 있다.▪ Rz에서 Rx로 이동하면 x축이 y축으로, y축이 z축으로 바뀐다.▪ 이러한 교체를 확인함으로써 Rx에 대한 행렬을 얻을 수 있다. CCW vs CW 회전▪ 자신을 향하는 축을 기준으로 CCW 회전이면 회전 각도는 양수이다.▪ 회전이 CW인 경우, 그 행렬은 음의 회전 각도로 정의된다.▪ -θ만큼 회전하는 것은 2π-θ만큼 회전하는 것과 같다.4. World TransformObject space vs. world space▪ 객체 생성에 사용되는 좌표계를 object space라고 한다.▪ 모델의 object space는 일반적으로 다른 모델의 object space과 관계가 없다.▪ world transform은 모든 모델을 world space라는 단일 좌표계로 조립한다.+α. Inverse Rotation회전 행렬 R이 주어지면 열(u, v, n)은 orthonormal basis를 구성한다.즉, u·u= v·v= n·n= 1 이고 u·v= v·n= n·u= 0 이다.R의 전치에 R을 곱해 보자.이는 회전 행렬의 역행렬이 전치임을 의미한다. u, v 및 n이 R의 열을 구성한다는 것을 기억하자. R-1(역)=RT(전치)이므로 u, v 및 n이 R-1(역)의 행을 구성한다.위 개념을 숙지하고, 아래 그림을 이해하자." }, { "title": "리눅스로 1학기 - Week.10) GitHub Desktop", "url": "/posts/linux11/", "categories": "리눅스", "tags": "Linux", "date": "2022-07-09 23:25:59 +0900", "snippet": "깃허브에서 서비스하는, 브라우저에 의존하지 않고 데스크탑에서 GitHub와 상호작용할 수 있는 도구마지막으로 리눅스에 설치할 소프트웨어는 깃허브 데스크탑이다. 아톰을 설치한 이후 웹 개발이 노트북에서도 가능해졌으므로, 코드파일을 효율적으로 주고받기 위해 깃허브 데스크탑을 설치하기로 하였다.[깃허브 데스크탑 공식 홈페이지서 리눅스를 지원하지 않는다]이 부분은 전혀 예상하지 못했다. 당연히 지원할 줄 알았던 리눅스 버전용 깃허브 데스크탑이 보이질 않고, widnow와 mac버전만 지원하고 있었다. 물론 그렇다고 방법이 없는 것은 아니었다.[shiftkey라는 개발자가 snap형식으로 GitHubDesktop의 리눅스 버전을 배포하고 있었다]https://github.com/shiftkey/desktop/releases/tag/release-2.0.4-linux1위 사이트로 들어가면, 깃허브 데스크탑의 리눅스 버전을 다운받을 수 있다. 나는 snap형식의 파일을 다운받아 터미널을 통해 설치하기로 하였다.[터미널에 snap install 명령어를 통해 파일을 설치한다]snap install ~/Downloads/GitHubDesktop-linux-2.0.4-linux1.snap –classic –dangerous이전에 krita를 설치할 때 snap을 사용한 기억이 있다. 역시 간편하게 설치가 진행되었다.[성공적으로 설치가 완료되었다]]이제 리눅스 환경에서 작성한 웹개발 코드를 간편하게 깃허브에 올릴 수 있게 되었다. 실행도 문제없이 되는 것을 확인하였니, 앞으로의 작업에 많은 도움이 될 것이라 기대한다.[소프트웨어센터에서도 제공하지 않는다]깃허브 데스크탑 홈페이지에는 없지만 혹시 소프트웨어 센터에서는 지원하고 있나 싶어 찾아보았다. 역시 존재하지 않았다. 왜 공식 홈페이지에서 리눅스 버전의 깃허브 데스크탑을 배포하지 않는지는 의문이다.평가길다면 길었고, 짧다면 짧았던 한 학기가 지났다. 프로그램 설치 하나에 한 시간이 걸리던 초반에 비해, 지금은 꽤나 리눅스에 익숙해진 듯한 느낌이 든다. 물론 겨우 한 학기 만으로 리눅스를 공부했다고 말할 수는 없겠지만, 평생을 써오던 윈도우 운영체제에서 벗어나 리눅스에서 아둥바둥 거렸던 작은 경험은 앞으로의 개발자 생활에 있어 큰 도움이 될 것이라 생각한다." }, { "title": "리눅스로 1학기 - Week.9) Atom", "url": "/posts/linux10/", "categories": "리눅스", "tags": "Linux", "date": "2022-07-09 23:25:59 +0900", "snippet": "자유 오픈소스 형태의 OS X, 리눅스, 윈도우용 문서 및 소스 코드 편집기웹 개발을 위한 소스코드 편집기를 설치하기로 하였다. 그동안 개발 목적으로 사용하는 컴파일러 및 IDE는 visual studio와 visual studio code가 메인이었다. 당연히 리눅스에도 VSC로 설치할 생각이었지만, 무언가 다른 소스코드 편집기도 사용해보고 싶어, VSC를 제외한 툴을 찾아보다 결국 ATOM으로 결정했다. 아톰은 무려 깃허브에서 제공한다. 오픈소스 프로그램인 만큼 당연히 리눅스 버전을 지원한다.[리눅스용 아톰을 설치한다].deb버전을 다운받아 설치한다. 그런데 이번에는 동시에 .rpm 확장자를 제공하고 있었다. 알아보니, rpm은 일반적으로 rpm패키지라고 부르며, 윈도우의 setup.exe정도의 역할을 한다고 한다. 즉 프로그램을 설치한 후 바로 실행하는 것이다. 레드햇에서 제공하는 리눅스에서만 사용할 수 있는 패키지 인스톨이지만 지금은 여러 리눅스 배포판으로도 이식되었으며, 각종 소프트웨어의 설치와 업데이트가 매우 편리하다는 장점이 있었다.[정석적인 순서대로 파일을 다운받아 설치를 진행한다][아톰이 설치되었다]웹 개발은 여러 소스코드 편집기로 할 수 있다. Notepad++도 설치 후보군에 있었지만, 내가 아톰으로 결정한 이유는 아톰이 더 개발자 친화적이라고 생각되었기 때문이다. 우선, 편집기부터 html기반으로 만들어져있다. 따라서 웹개발을 하듯 편집기를 직접 편집할 수 있으며, 두 번째는 emmet이라는 패키지 때문이다. 웹개발 코드를 작성함에 있어서 매우 편리한 자동완성 기능을 제공한다.[아톰을 열어, install package - emmet을 설치해준다][1차 세팅이 끝났다]이제 리눅스에서도 웹 개발을 할 수 있다!평가어느덧 리눅스를 사용한지도 두어달이 넘아간다. 확실히, 학기 초에 비해서는 리눅스가 이제 낯설지 않다. 오히려 윈도우에서 찾지 못한 리눅스의 장점이 계속 보이기도 한다." }, { "title": "리눅스로 1학기 - Week.8) Chrome", "url": "/posts/linux9/", "categories": "리눅스", "tags": "Linux", "date": "2022-07-09 23:16:12 +0900", "snippet": "구글에서 개발하고 서비스하는 프리웨어 웹 브라우저크롬은 프로젝트 준비 당시에는 설치할 계획이 없는 소프트웨어였다. ubuntu에는 기본 인터넷 브라우저로 firefox가 설치되어있기에 새로운 os에 적응하는 겸 해서 브라우저 역시 firefox를 사용할 예정이지만, 아무래도 웹 개발, 특히 개발자도구와 CSS미리보기는 크롬만한 브라우저가 없다고 생각되어 결국 설치하게 되었다.[오히려 없으면 이상했을 리눅스 버전 크롬]구글의 개발환경이 리눅스인데, 당연히 크롬은 리눅스 버전을 지원할 것이라 생각했다. 64비트의 deb파일을 다운로드하여 설치를 진행한다.[저장 후 설치과정을 거친 다른 파일들이 보인다]소프트웨어 패키지를 다운로드와 동시에 실행을 하니 설치에 실패한다는 메시지가 뜬다. 이전에도 deb파일은 유사한 오류를 종종 내곤 했다. 어쩔 수 없이 저장과정을 한번 거쳐 실행하기로 한다. 그러다, 설치와 관련한 에러메시지는 항상 소프트웨어센터를 통해 확인하게 되는 것을 문득 깨달았다. 안드로이드 스마트폰의 플레이스토어처럼 우분투의 관련 프로그램에 대하여 전체적인 설치 관리를 담당하는 역할을 하는 것이 아닐까 라는 생각이 들었다.이에 궁금해져서 찾아보니, 우분투 소프트웨어 센터는 우분투용 플랫폼 스토어이자 저장소역할을 한다고 한다. 어플리케이션 저장소 서버와 APT, dpkg와 같은 소프트웨어 패키지 툴 및 클라이언트의 우분투 소프트웨어를 기반으로 기능한다고 동작한다고 하니 역시 우분투의 프로그램에 대하여 전체적인 설치를 담당하는 것이 맞았다. [크롬을 수동으로 설치한다]아마 늦게 설치한 프로그램 중 가장 사용빈도가 많은 프로그램이 될 것이다. 어차피 설치할 것이였으면 가장 먼저 설치했으면 좋았을 거라는 후회가 약간은 든다.[정상적으로 작동한다]평가설치 소프트웨어가 많아지면서, 점점 설치과정보다는 리눅스 사용과 접근성 개선에 조금 더 중점을 두게 된다. 리눅스로 넘어오면서 firefox도 나름 쓸만하게 사용하고 있었지만, 내가 크롬 개발자도구에 익숙해져서인지 여전히 크롬 버전이 더 편리하고 직관적인 듯한 느낌을 주는 듯 하다." }, { "title": "리눅스로 1학기 - Week.7) Audacity", "url": "/posts/linux8/", "categories": "리눅스", "tags": "Linux", "date": "2022-07-09 22:39:02 +0900", "snippet": "무료 오픈소스 멀티트랙 오디오 편집기이번에는 Audacity라는 오디오 편집 프로그램을 Ubuntu에서 사용해 볼 것이다. 본래 작업 환경인 Windows 데스크탑에서는 GoldWave라는 프로그램을 사용하였지만, 리눅스 환경에서는 리눅스 환경에 맞는 프로그램을 다뤄보기로 했다.[홈페이지의 소개부터 윈도우, 맥, 리눅스 모두 지원함을 알 수 있다]이전과 다를 바 없이 오다시티 홈페이지에서 다운받아 설치할 수도, 터미널을 통해 설치할 수도 있지만 이번 주의 목적은 설치보다는 프로그램 사용에 있기 때문에 설치과정은 간단하게 소프트웨어센터를 통해 설치하기로 하였다. 오픈소스 프로그램인 만큼 당연히 소프트웨어센터에서도 제공하고 있음을 알 수 있다.[audacity가 잘 설치 되었다]점점 프로그램들이 늘어나는 것이 보인다. 이제 Ubuntu도 내 환경에 맞는 작업 컴퓨터 중 하나로 변화하는 것 같은 느낌이 든다.프로그램도 정상 작동한다. GoldWave랑 상당히 유사한 화면을 볼 수 있다.처음 봐도 익숙한 메인 화면이 보인다. 주로 사운드 이펙트의 편집이나 작곡한 음악의 확장자 변환, 후처리를 할 때 오디오 에디터를 사용했는데, 역시 프로그램 모두 비슷한 것 같다. 이제 저 빈 공간에 음악 파일을 가져올 것이다.[이전에 설치한 디스코드를 통해 음악 파일을 가져왔다]데스크탑에서 FL studio로 만든 노래를 이전에 설치한 디스코드를 통해 우분투로 가져왔다. (우분투에서는 video player로 음악 파일이 열린다.) film music study라는 음악 파일을 Audacity에서 불러오자.[이제 우분투에서도 오디오 편집이 가능하다]평가https://soundcloud.com/d0g39akgu7q7/upload-test 에서 편집과정을 거친 위 노래를 들어볼 수 있다. 작곡을 공부하면서 처음 만든 NCS스타일의 노래라 상당히 허접하지만, 인증용으로 남겨두었다." }, { "title": "리눅스로 1학기 - Week.6) Krita", "url": "/posts/linux7/", "categories": "리눅스", "tags": "Linux", "date": "2022-07-03 11:21:26 +0900", "snippet": "KDE 리눅스 인터페이스의 표준 이미지 에디터인, 디지털 드로잉을 위한 자유 오픈소스 페인팅 프로그램.리눅스에서 설치하는 페인팅 프로그램이다. 다른 페인팅 프로그램과 달리 오픈소스라는 특징에 맞게 무료인 것이 장점이며, 그럼에도 불구하고 상당히 좋은 기능을 갖추고 있어 윈도우에서도 몇 번 사용해본 적이 있다. 지금 윈도우에서는 다른 툴을 사용하나, 이전까지는 Krita가 오픈소스 프로그램이 아니라 상업용의 프로그램으로 알고 있었을 정도였다.[Krita 홈페이지에서 리눅스 버전을 바로 다운받을 수 있다][터미널을 통해 Krita를 설치한다]Ubuntu의 터미널에서 sudo snap install krita를 입력하니, 바로 다운로드부터 설치까지 진행되었다. 정말 빠르고 간편하게 진행되었는데, 이를 도와준 snap이 무엇인지 알아보자.snapsnap은 apt와 같은 프로그램 설치 방법과 달리, 프로그램 실행에 필요한 라이브러리 등을 모두 포함하고 있다. 비슷한 것으로 appimage가 있는데, krita의 공식 홈페이지에서도 리눅스 버전을 다운로드 할 때 deb가 아닌 appimage로 다운로드를 받으라는 안내가 나왔었다. apt나 dpkg와 달리 리눅스 사용자를 위한 더 간편한 방법을 제공하고 있었다. 다만, snap은 데비안 패키지 관리자 파일보다 용량이 더 크다는 단점이 있었다.정상적으로 동작한다.[물론 소프트웨어센터에서도 Krita를 제공하고 있다.]노트북에 테블릿을 연결하여 직접 조작해보았다. 가상머신에서 실행한 이유인지는 모르겠으나, Krita의 페인팅 화면에서 생각보다 드로잉에 자잘한 렉이 발생했다. 마우스로는 작업이 많이 힘들었고, 펜으로도 생각처럼 잘 움직이지는 않았다. 후에 krita의 최적화나, 실제 os에서 작업을 해보면 또 다를 것이라 기대한다.평가Krita 마스코트 캐릭터를 간단하게 그려보았다.자잘한 렉만 빼면, 리눅스 환경에서도 디자인 작업이 가능해질 것 같다" }, { "title": "리눅스로 1학기 - Week.5) Discord + gdebi", "url": "/posts/linux6/", "categories": "리눅스", "tags": "Linux", "date": "2022-07-03 11:13:59 +0900", "snippet": "게이밍부터, 교육과 비즈니스영역의 커뮤니티 생성을 목적으로 설계된 VoIP 응용 소프트웨어자료 공유와 화면 공유, 텍스트 및 보이스 채팅 기능이나 협업의 목적으로 최근 내가 가장 많이 사용하는 소프트웨어 중 하나이다. [소프트웨어센터에도 디스코드를 찾을 수 있다]리브레 오피스를 다운 받았던 소프트웨어센터 메인 화면에 디스코드 바로 보인다. 그만큼 인기가 높은 소프트웨임을 실감할 수 있었다. 하지만, 리눅스 사용에 더 익숙해지기 위해 소프트웨어센터는 잠시 접어두고 터미널을 통해 직접 설치해보자.터미널에서 wget을 통해 디스코드를 다운받는다. wget이란, GNU Wget로써 웹 서버부터 콘텐츠를 가져오는 컴퓨터 프로그램으로, GNU 프로젝트의 일부이다. wget 명령어 뒤에 디스코드 홈페이지 주소를 통해 다운받는다.[설치를 할 수 없다][디스코드 홈페이지에서 리눅스용 deb파일을 받아도 에러가 발생한다]그러나 알 수 없는 이유로 설치에 실패했다는 메시지만 보이고 있다. 하는 수 없이 디스코드 홈페이지에서 직접 리눅스용 deb파일을 내려받아 설치를 하려고 해도, 똑같은 에러 메시지만 출력한다. 이를 해결할 방법을 찾아보자가끔 리눅스에서 deb파일을 설치할 수 없는 경우, gdebi를 설치하여 해당 프로그램으로 설치를 진행할 수 있다고 한다.sudo apt-get install gdebi로 gdebi 설치를 진행해준다.[터미널을 통해 gdebi를 설치했다][gdebi로 패키지를 선택한다][discord.deb파일을 선택해 설치를 진행한다]playonlinux를 사용할 때와 비슷하게, 다운받은 프로그램 파일을 설치하는 구조로 이어져 있다. 차이점이라면 playonlinux는 윈도우 파일을, gdebi는 deb파일을 설치하는 것.평가디스코드는 다른 프로그램들과 달리 메인 홈페이지부터 리눅스용 deb파일을 제공하고 있었다. 그러나 쉽게 생각했던 예상과 달리, deb파일의 경우도 설치에 실패할 수 있다는 것을 알게 되었다. 일반적으로 우분투의 버전문제라고 하며, 조금 더 찾아보니 역시 이러한 경우에도 해결방법은 있었다. 그래도 주차가 진행될수록 상황과 에러에 조금씩 유연해지는 것 같다." }, { "title": "리눅스로 1학기 - Week.4) LibreOffice Draw", "url": "/posts/linux5/", "categories": "리눅스", "tags": "Linux", "date": "2022-07-03 02:32:12 +0900", "snippet": "무료 오픈소스 벡터 그래픽 편집기.소프트웨어개발방법및도구 수업을 통해 알게 된 소프트웨어 설계도 디자인 프로그램이다. 여러 프로그램 중 리브레 오피스는 리눅스에서도 설치가 가능하다는 정보로 리눅스에서 설치부터 디자인 과제 완성까지 진행해보기로 하였다.[리눅스를 지원하는 오픈소스 프로그램]지금까지 만났던 프로그램들과는 다르게 메인 홈페이지부터 리눅스 버전 설치 프로그램을 제공한다. Wine을 설치할 때처럼, deb버전으로 프로그램을 제공하고 있는 것을 알 수 있다.다운로드부터 압축파일까지 모두 리눅스로 직접 제어가 가능하다.리브레 오피스 드로우를 다운받고, 설치만을 남겨둔 상황에서 새로운 정보를 알게 되었다. Ubuntu 에서는 프로그램 스토어의 역할을 담당하는 소프트웨어센터라는 어플을 제공하는데, 그 경로를 통해서도 리브레 오피스를 다운받을 수 있다는 것이다.소프트웨어센터를 둘러보니, LibreOffice Draw를, 홈페이지를 통하지 않고 다이렉트로 다운로드를 제공하는 것을 확인했다.마치 윈도우 환경인 것처럼, 클릭 몇 번으로 프로그램이 설치되었다.[이제 우분투에서 LibreOffice Draw를 사용할 수 있다.]평가Ubuntu의 편의성을 하나 더 알아가는 과정이었다. 리눅스는 모두 번거로운 절차를 통해 프로그램을 설치해야 하는 줄 알았는데, 이런 편리한 기능이 있는 점이 감사하게 느껴지기도 한다. 소프트웨어센터를 둘러보니 내가 필요로 하는 여러 프로그램들을 제공하고 있어 리눅스 사용이 더 간편해질 것 같다. 하지만, 이번 학기의 주된 목적은 리눅스에 익숙해 지는 것이기 때문에 터미널을 더 자주 사용해야 할 것이다." }, { "title": "리눅스로 1학기 - Week.3) Kakao Talk", "url": "/posts/linux4/", "categories": "리눅스", "tags": "Linux", "date": "2022-07-02 17:44:11 +0900", "snippet": "주식회사 카카오가 서비스하는 글로벌 모바일 인스턴트 메신저.윈도우 환경에서도 자주 사용했던 소프트웨어를 이제 리눅스에서 만날 것이다. 카카오톡은 단순히 메신저 기능으로써 뿐만 아니라 파일의 전송에도 자주 사용되고 있어, 스마트폰 뿐만 아니라 컴퓨터에도 많이 설치하는 소프트웨어로 자리잡았다.[당연히, PC버전에는 Windows와 Mac버전만이 있다.]카카오에서 따로 리눅스를 위한 버전을 제공하지 않으므로, Windows버전으로 받아 PlayOnLinux를 통해 설치해야 한다. 평소에는 생각하지도 않을 문제였지만, 지금에 와서는 두 가지 버전만이 있는 것이 조금 어색하게 느껴졌다.[PlayOnLinux로 KakaoTalk의 exe확장자명을 가진 프로그램을 설치한다.]처음에는, Wine의 버전과 문제가 있어 한 번 당황했었다. 하지만 이내 고쳐잡고 나니 순조롭게 설치가 진행되었다.[처음으로 리눅스 환경에서 반가운 장면을 보았다.]이번 학기 Ubuntu는 영어 환경에서 살아볼 것이기 때문에, 한글화는 과감히 생략했다. 그래서 카카오톡의 언어 선택지에도 영어밖에 없다. [압축을 풀고 카카오톡이 설치되고 있다.][이제 리눅스 컴퓨터로도 카카오톡을 할 수 있다.]평가우분투에서 한글화를 하지 않았지만, 그렇다고 해서 카카오톡의 친구 이름도 한글이 깨져 나올 것이라고는 예상하지 못했다. 앞으로 한글이 더 필요한 상황이 오면 패치를 새롭게 할 생각이다. 앞서 설치한 playonlinux와 wine으로, 이번 카카오톡 설치는 비교적 간단히 진행되었다." }, { "title": "리눅스로 1학기 - Week.2) Wine", "url": "/posts/linux3/", "categories": "리눅스", "tags": "Linux", "date": "2022-07-02 17:37:56 +0900", "snippet": "마이크로소프트 윈도우 전용 프로그램을 유닉스 계열 운영체제에 실행하기 위한 호환성 계층이다.Wine의 풀네임은 Wine Is Not an Emulator로, 이름부터 에뮬레이터가 아니라 호환 레이어임을 나타내고 있다. 윈도우에서 제작된 바이너리 프로그램을 해독하는 계층이라는 것을 지속적으로 강조한다.이전까지는 PlayOnLinux가, 모든 소프트웨어를 어려움 없이 설치할 수 있는 만능 프로그램 정도로 알고 있었다. 하지만, Wine이라는 또 다른 프로그램을 필요로 한다는 것을 알게 되었다.다른 소프트웨어 프로그램을 설치하려 하니 PlayOnLinux에서 Wine이란 것에 문제가 있다고 한다.PlayOnLinux와 Wine의 차이점이 뭘까.설명만 보아서는 이해가 잘 되지 않는다. 조금 더 자세히 알아보자.위의 설명에서 이어 말하면, PlayOnLinux는 리눅스에서 윈도우 소프트웨어를 설치, 실행 및 관리하는데 도움을 주는 프로그램이고, Wine은 윈도우용으로 개발된 프로그램이 Linux를 포함하여 macOS와 같은 기타 UNIX 시스템과 같은 운영 체제에서 실행될 수 있도록 하는 호환성 계층인 것이다.[프로그램을 설치하면서 만나는 첫 에러. PlayOnLinux가 아니라 Wine에서 문제를 보인다.]wine의 버전을 업그레이드 하니, 윈도우10까지 프로그램이 호환되는 것을 확인했다.[5.0.2버전이 호환성면에서 가장 안정성이 좋다고 한다]터미널에 sudo dpkg —add—architecture i386sudo apt install wine playonlinux를 입력하여 설치해준다.dpkg는 데비안 계열 패키지(.deb 확장자명을 가진 소프트웨어)를 설치할 때 사용된다.dpkg는 apt보다 낮은 단계에서 패키지를 관리하기 때문에 패키지 간의 의존성을 보지 않고 각각의 패키지에 대해서만 대응한다.[wine을 검색하면 PlayOnLinux가 나온다]평가wine과 playonlinux는 사실 거의 붙어있는 프로그램이라 보아도 무방하다. 그럼에도 둘을 굳이 분리해서 따로 조사한 이유는, 단순히 한 소프트웨어에 묻고 가기에는 알아야 할 지식이 많고, 앞으로의 리눅스 생활에 있어 더 빠른 이해를 하기 위함이다. 하나를 알려면 다른 하나를 알아야 한다. 꼬리에 꼬리를 무는 지식 요구에 넘어야 할 산이 많다는 것을 느낀다." }, { "title": "리눅스로 1학기 - Week.1) Play On Linux", "url": "/posts/linux2/", "categories": "리눅스", "tags": "Linux", "date": "2022-07-02 17:25:28 +0900", "snippet": "윈도우, 애플 기반 응용 프로그램을 리눅스에 설치할 수 있도록 도와주는 프로그램. 앞으로 계획된 소프트웨어들을 리눅스에서 사용하기 위해 필수적으로 설치해야하는 소프트웨어이다.리눅스는 Window나 Mac과 달리 터미널이라는 기능이 특히 발달되어 있다. 소프트웨어 설치 역시도 일반적으로 행했던 홈페이지에서 다운로드, 설치로 이어지는 구조가 아니라 터미널에서의 명령어 입력을 거쳐야 한다.[apt로 PlayOnLinux를 설치하는 과정]소프트웨어 설치를 위해 구글링을 이렇게 오래 한 적은 처음이다. 시작부터 험난하다. 터미널에 ($) sudo apt install playonlinux로 설치한다.apt: advanced package manager 명령어로써 패키지 다운로드나 설치를 수동으로 할 필요 없이 단순히 설치할 패키지의 이름만 지정해 주면 시스템이 알아서 패키지 다운로드 및 설치, 업그레이드를 해준다. apt를 사용한 명령어가 많으니 알아두면 좋을 듯하다.[Ubuntu에 PlayOnLinux가 설치되었다.]긴 시간 끝에 설치를 끝냈다. 이제 PlayOnLinux를 실행시켜 보자.[생각보다 심플하다.]아직 설치한 소프트웨어가 없어 아무것도 뜨지 않는다. 앞으로 설치할 소프트웨어들은 이 PlayOnLinux의 메인 화면에 표시될 것이다.평가리눅스와 함께했던 첫 걸음이다. 윈도우에서는 당연하게 했던 것들이 여기서는 혹시 에러가 나지 않을까 조마조마 했다. 그래도 처음이 어렵지, 시간이 지날수록 점차 익숙해지리라 믿는다. 처음 마주하는 생소한 환경이 조금 낯설기도 했지만, 이 색다른 환경이 마치 새로운 전자제품을 구매한 듯한 기분을 나게 해주어 묘하게 들뜨기도 한다. 여기까지는 큰 어려움이 없었다. 하지만, 앞으로의 고된 길이 보이는 것 같다" }, { "title": "리눅스로 1학기", "url": "/posts/linux1/", "categories": "리눅스", "tags": "Linux", "date": "2022-07-02 16:40:29 +0900", "snippet": "작년 한 학기 동안, 내 PC의 메인 운영체제를 리눅스로 살아보는 경험을 했었다.시작은 불편하고 힘들었지만, 결과적으로 큰 도움이 되었던 기억이 난다. git을 더 자주 쓰는 지금에는 오히려 리눅스였다면.. 하는 생각이 들기도 한다.그 지난 경험을 블로그에 기록한다.목적내 컴퓨터 사용의 가장 큰 비율을 차지하고 있는 프로그래밍 영역은 모두 데스크탑에서 이루어지고 있다. 많은 용량과 높은 사양의 그래픽을 요구하기 때문에 노트북에서는 그러한 무거운 개발을 잘 하지 않는다. 카페나 기타 회의실 및 야외에서 주로 사용하는 노트북은 비교적 가벼운 개발이나 알고리즘, 개발 외 작업 등이 주 목적이었다. 따라서 노트북은 데스크탑에 비해 컴퓨터의 용량 정리나 파일 관리에 있어 크게 조심해야 할 부분이 없었고, 중요한 파일이 많지 않았다. 이러한 이유로 노트북에서 먼저 리눅스 사용성을 검증하고, 이후 데스크탑으로 확장시키는 경로를 생각하였다. 서브 프로젝트 용도로 사용되었던 노트북에 리눅스 작업 환경을 구축해보고, 개발, 비개발 영역의 작업 환경으로써 그 사용성을 검증한다.설치LG gram에 가상머신 vmware를 사용하여 ubuntu를 설치하였다. vmware 자체에서 제공하는 ubuntu와 ubuntu 공식 사이트에서 ISO파일을 받아 설치하는 것의 두 가지 방법이 있었고, 테스트를 거쳐 후자의 방법으로 설치한 환경을 사용하기로 하였다.다양한 Linux기반의 OS중, ubuntu를 선택한 이유는 다음과 같다. 무료이다. 대중성과 접근성이 비교적 높았다. =&gt; 자료가 많았다. 보안이 우수하다긴 시간 끝에 vmware에 ubuntu를 설치했다. 한 번의 시행착오를 거쳐 드디어 구동에 성공했다.[ubuntu에 진입했다!]이전에 칼리 리눅스를 공부하기 위해 리눅스를 잠깐 건드린 적이 있지만, 쉽게 적응할 수 없는 운영체제이다. 웹 서버를 공부하려면 언젠가는 리눅스와 친해져야 하기에, 지금부터 에러란 에러는 모두 체험할 예정이다.우분투 적응훈련은 아래 10개의 소프트웨어를 설치하고 사용해보는 것으로 진행해나간다. 소프트웨어 기능 PlayOnLinux 윈도우, 애플 기반 응용 프로그램을 리눅스에 설치할 수 있도록 도와주는 프로그램 Wine 윈도우가 아닌 운영체제에서 윈도우 기반 프로그램을 실행하도록 도와주는 프로그램 Kakao Talk 카카오가 서비스하는 글로벌 모바일 인스턴트 메신저 LibreOfficeDraw 무료 오픈소스 벡터 그래픽 편집기 Discord (+gdebi) VoIP응용 소프트웨어, 온라인 메신저 Krita 디지털 드로잉을 위한 자유 오픈소스 페인팅 프로그램 Audacity 무료 오픈소스 멀티트랙 오디오 편집기 Chrome 구글에서 개발하고 서비스하는 프리웨어 웹 브라우저 Atom 자유 오픈소스 형태의 OS X, 리눅스, 윈도우용 문서 및 소스 코드 편집기 GitHub Desktop 깃허브에서 서비스하는, 브라우저에 의존하지 않고 데스크탑에서 GitHub와 상호작용할 수 있는 도구 이제 각 소프트웨어를 설치해보고, 그 과정을 기록해 둘 것이다!" }, { "title": "그래픽스 기본 개념2", "url": "/posts/graphics2/", "categories": "그래픽스", "tags": "graphics", "date": "2022-07-02 14:55:19 +0900", "snippet": "그래픽스에서 물체의 회전과 이동을 어떻게 하는지 알아보겠습니다. 따라서 이번 포스트는 그래픽스 개념 보다는 이를 이해하기 위한 사전지식인 선형대수에 더 가깝습니다.이 포스트는 경희대학교 게임 그래픽 프로그래밍 수업자료를 바탕으로 합니다.1. 2D rotation벡터의 2D 회전을 알아보자.▪ 벡터 p는 원점을 중심으로 θ만큼 회전하여 p ́를 정의한다.▪ p의 길이가 r일 때 좌표는 (rcosΘ, rsinΘ)이고, 이를 이용하여 p ́의 좌표는 고등학교에서 배운 삼각함수 덧셈 공식으로 다음과 같이 계산할 수 있다.이는 행렬-벡터 곱셈 형식으로 결합될 수 있다.이 공식의 R(Θ)가 rotation matrirx가 된다.회전의 예시는 다음과 같다.▪ 기본적으로 회전은 시계 반대 방향을 양수로 한다.▪ 따라서, θ에 의한 시계방향 회전 행렬은 2차원 회전 행렬에 -θ를 대입하여 구한다.▪ -θ만큼 회전하는 것은 2π-θ만큼 회전하는 같은 것. (R-90°) = R(270°)2. Translation▪ Translation은 (x, y)의 점을 (x + dx, y + dy)로 이동하는 것이다.▪ (dx, dy) translation 벡터를 호출한다.▪ 점의 2차원 데카르트 좌표(x, y)가 주어지면, 3차원 벡터(x, y, 1)를 동차 좌표(homogeneous coordinates)로 사용할 수 있다.이 식을 위해서는 아래 개념을 이해해야 한다.homogeneous coordinates▪ 2D에 점(x, y)이 주어지면 homogeneous coordinates는 (x, y, 1)이 아니라 w가 0이 아닌 (wx, wy, w)이다.▪ 예를 들어, 데카르트 좌표 (2, 1)을 (2, 1, 1), (4, 2, 2), (6, 3, 3) 등의 동차 좌표로 변환할 수 있다.▪ 동차 좌표(X, Y, w)가 주어졌다고 가정했을 때, 모든 좌표를 w로 나누면 (X/w, Y/w, 1)을 얻는다. 이는 선의 한 점을 평면에 투영하는 것에 해당한다. w= 1 이고, 처음 두 구성요소(X/w, Y/w)를 데카르트 좌표로 사용한다.3. 실습이제 실제로 회전과 이동을 적용시켜 보자.지금까지 배운 회전과 이동은 원점을 기준으로 설명한 것이다. 먼저 원점을 기준으로 알아보겠다.▪ 행렬 곱셈은 비가환적이며, 이는 곱셈 순서가 중요함을 의미한다. 아래 예제를 보자.▪ Rotation (R) followed by translation (T) vs. T followed by R그렇다면, 임의의 점에 대한 회전과 이동은 어떻게 할까?▪ 임의의 점 (a,b)를 중심으로 (x,y)에서 점 회전은 아래 순서를 따른다. (x, y)를 (-a, -b)로 translating 원점을 기준으로 translated point 회전 rotated point를 (a,b)로 back-translating즉 원점으로 보내고 돌린 후 다시 복귀시키는 것" }, { "title": "카테고리 소개", "url": "/posts/memo0/", "categories": "개발 메모", "tags": "game dev, memo", "date": "2022-06-27 19:08:00 +0900", "snippet": "대략 2년 전 기록했던 정보들을 포함하여, 최근 새롭게 알게된 정보까지 이 포스트에 옮겨 적는다. 자꾸 까먹거나, 알아두면 유용한 정보들 등을 생각날 때 마다 하나씩 기록한다." }, { "title": "GDF 2018 참여", "url": "/posts/gdf2018/", "categories": "다이어리", "tags": "GDF 2018", "date": "2022-06-25 21:16:13 +0900", "snippet": "자료를 정리하다, 학부 1학년 시절 참가한 VR관련 포럼 사진을 발견했다. 블로그에 기록해두자. 판교 경기창조경제혁신센터 국제회의장에서 열린 VR 글로벌 개발자 포럼에 참여하였다.(2018.07.20)당시 컨퍼런스의 주제는 VR-퍼블릭, VR-커머스, VR-컨버전스, VR-e스포츠 4개 분야로 나뉘어, 각 분야 전문가 분들의 다양한 의견을 들을 수 있었다." }, { "title": "그래픽스 기본 개념1", "url": "/posts/graphics1/", "categories": "그래픽스", "tags": "graphics", "date": "2022-06-25 19:08:26 +0900", "snippet": "블로그에서는 그래픽스와 관련한 공부를 DirectX로 진행하지만, 기본적인 개념은 openGL을 사용하기도 합니다. 이번 포스트에서는 기초적인 지식을 기록합니다.이 포스트는 경희대학교 게임 그래픽 프로그래밍 수업자료를 바탕으로 합니다.1. vertex 계산컴퓨터에서는 mesh를 vertices로 나누어 계산하게 된다.▪ vertices는 vertex array라는 이름의 메모리 공간에 열거된다.▪ 세 꼭짓점을 선형 순서로 읽어 삼각형을 만든다.▪ DirectX에서 vertex가 들어가는 순서는 LHS이다. (openGL의 경우 RHS)▪ vertex array에 저장되는 데이터는 vertex 위치 뿐만 아니라, 추가적인 정보(색상, 법선 등)가 포함된다.위와 같이 처리하면, vertex array에 중복으로 데이터가 포함되어 심각한 메모리 낭비를 가져온다(위의 사진처럼 t1, t2, t3 세 개 단위로 끊어 삼각형을 만든다, 그러나 중복되는 데이터가 포함된다)따라서, 컴퓨터는 조금 더 효율적인 index array를 사용하는 방법으로 vertex를 처리한다.▪ vertex array에 정점을 넣고, index array라는 배열을 따로 만든다.▪ 각 vertex는 vertex array에서 한 번만 저장되므로, 중복을 피할 수 있다.▪ vertex를 참조하여 삼각형을 그릴 때는 index array를 보고 그리게 된다. 이렇게 하면 vertex array에는 중복이 일어나지 않는다.코드의 예시는 아래와 같다.DrawIndexPrimitive(D3DPT_TRIANGLELIST, 0, 0, 4, 0, 2)순서대로 (타입, BaseVertexIndex, MinIndex, NumVertices, StartIndex, 그릴 삼각형 개수)2. Surface Normals▪ Normal은 주어진 점에서 접하는 표면에 수직인 벡터이다.▪ 특정 지점에서 물체 표면의 밝기는 해당 지점의 법선(Normal)과 빛의 방향이 이루는 각도에 따라 달라진다. 서로 마주보면 매우 밝을 것이다. 각도가 같으면 빛이 닿지 않는 곳이다.▪ Surface normals는 triangle normals과 vertex normals으로 분류된다.Surface Normals - Triangle normal▪ 주어진 삼각형(p1, p2, p3)에서 v1은 첫 번째 정점(p1)과 두 번째 정점(p2)을 연결하는 벡터라고 하자. 마찬가지로 첫 번째 정점(p1)과 세 번째 정점(p3)을 연결하는 벡터를 v2로 하자. 그러면 오른손 법칙에 따른 외적을 이용하여 삼각형 법선을 계산할 수 있다.▪ 모든 normal vector는 기본적으로 unit vector로 만들어진다.▪ p1, p2, p3는 시계 반대 방향(CCW)으로 정렬된다.위 그림처럼 v1과 v2를 외적한 Normal의 방향을 알 수 있다.Counter-clockwise(RHS) vs clockwise(LHS)▪정점을 시계 방향(CW), 즉 (p1, p3, p2)로 정렬한다면▪ normal은 반대 방향이다.▪ 법선 방향은 꼭짓점 순서에 따라 다르기 때문에 이를 반드시 잘 확인해야 한다.▪ 컴퓨터 그래픽에서 surface normal은 다면체를 가리켜야 한다. 이를 위해 verticies의 CCW 순서가 필요하다.Surface Normals – Vertex normal버텍스들이 어디를 보고 있는가는 어떻게 정의할까?▪ triangle normals 보다 더 중요한 것이 vertex normal이다. vertex normal으로 정점이 샘플링하는 매끄러운 표면 점의 normal에 근접하도록 normal을 vertex에 할당할 수 있다.▪ vertex normal은 vertex를 공유하는 모든 삼각형의 normal을 평균화하여 정의할 수 있다.vertex normal은 vertex array의 필수 구성 요소임을 기억하자위의 사진처럼 주변 삼각형 normal의 평균을 구해서 vertex normal을 구한다. 이 방식으로, 부드러운 surface를 구현할 수 있다.다만 이처럼 vertex normal을 이용해서 brightness를 표현할 때, 오히려 각진 표현을 하지 못하는 단점이 있다. 이는 face 별로 각각 따로 normal 정보를 계산하여 각을 살리거나 면에 새로운 작은 면을 삽입하여 각을 주는 방식으로 해결 가능하다." }, { "title": "UV 언랩과 맵핑", "url": "/posts/modeling1/", "categories": "디자인", "tags": "design, 3d modeling", "date": "2022-06-25 19:08:18 +0900", "snippet": "모델링 후 uv 언랩과 맵핑에 관하여(3D 오브젝트에 손맵 만들기)텍스쳐를 그리기 쉽게 분류하여 detach로 적절하게 오브젝트들을 분리한다. 만약 Symmetry효과를 적용하기를 원한다면, 미리 오브젝트 반은 없애주고 symmetry는 모든 작업이 끝난후 적용해주도록 하자.1. UV언랩과 OBJ 추출Editable poly상태에서 Unwrap UVW를 씌우고, Open UV Editor를 열어 Mapping - Normal Mapping - Back/Front Mapping으로 바꿔주고 전개도를 적절히 배치한다. 조정이 다 끝났으면 Tools - Renderer UVW Template 높이와 넓이를 조정해주고 (기본값 1024) Render UV Template를 눌러 텍스쳐를 targa 혹은 psd파일로 저장한다. 그리고 Editable poly와 Unwrap UVW Collapse를 꼭 해준다.그리고 File - Export - Export Selected로 선택한 오브젝트를 추출한다. Export Option 에서 Faces를 Triangles로 바꿔준다. (면을 삼각형으로 추출하는 것이 더 좋다) 설정이 끝나면 Export로 OBJ를 추출해준다.2. 맵핑Cinema4d의 BodyPaint 기능을 사용한다. (포토샵을 사용해도 상관없다) 오른쪽위의 Layout을 BP - 3D Paint로 바꿔준다. File - Open Project로 추출한 OBJ파일을 불러온다. Import옵션을 확인하고 (아마 맥스의 경우 Flip Z Axis로 체크되어있을 것) 오브젝트를 불러오고 나면 Project Settings에서 Linear Workflow를 체크 해제해준다. (본래 색을 보기 위함) *Project Settings는 Mode부분에서 볼 수 있다.그 후, Materials에서 머티리얼을 더블 클릭하여 에디터를 열어준다. V값을 100으로 만들어주고, 왼쪽의 체크박스는 Color빼고 모두 체크를 지워준다. 그리고 Texture의 붉은 동그라미 부분에서 아까 맥스에서 추출한 이미지 텍스쳐 파일을 불러온다. 그럼 이제 Layers창에 Background와 Alpha 레이어가 보일 것이다.(지금도 보이지 않는다면 왼쪽 상단 view옆의 Texture창에 들어가 File - Open Texture에서 직접 텍스쳐를 불러와준다) 이제 맵핑 작업을 하면 된다. (View창의 추천 세팅은 Camera는 Parallel, Display는 Constant Shading N ~ E이다) 작업을 끝마치고 나면 file - save project as 혹은, Texture창의 file - save Texture as에서 PSD파일로 저장해준다. 개인의견) 와콤으로 바디페인트에서 텍스쳐 작업을 하는것 보다는, 바디페인트에서 텍스쳐에 대략적인 위치와 밑그림만 잡아주고 본 작업은 패드나 타 페인팅 프로그램에서 진행하는게 더 편했음3. 머티리얼 적용맥스에서 Slate Material Editor를 연다. Standard를 불러오고, Diffuse Color에서 선을 뽑아 General - Bitmap에서 아까 C4d에서 추출한 PSD파일을 불러온다. 그리고 머티리얼 타이틀을 우클릭하여 Show Shaded Material in Viewport 체크가 되어있는지 확인한다. 이 머티리얼을 오른쪽의 원에서 뽑아 알맞은 오브젝트에 연결해주면 적용까지 성공.(모델링 중간과정)이제 기본적인 맵핑 작업이 끝났다. 이후 리깅작업을 하고, 엔진에서 맵핑 + 휴머노이트 세팅을 하면 된다." }, { "title": "깃허브 블로그 개설!", "url": "/posts/myFirstPost/", "categories": "다이어리", "tags": "", "date": "2022-06-25 19:08:00 +0900", "snippet": "깃허브 블로그를 개설했습니다" } ]
